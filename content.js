const SYLLABUS_MD = {"value":"# THE COMPLETE INTERVIEW BOOK\r\n# Senior Java / Spring Boot Backend Developer\r\n\r\n### For 7+ YoE | Java 8 → 21 | Spring Boot 2.x → 3.x | AI Integration\r\n### Self-Study Edition — Print-Ready\r\n\r\n---\r\n\r\n\u003e **How to use this book:**\r\n\u003e This is a self-contained study guide. Every topic starts with a **Definition** (what it is) and **Meaning** (why it matters in plain English). Each module opens with an **Internal Revision** section that refreshes the prerequisite basics you need before going deeper. Code snippets are included for every complex concept. You do NOT need any other resource.\r\n\u003e\r\n\u003e **Read order:** Module 1 → 13, sequentially. Each module builds on the previous.\r\n\r\n---\r\n\r\n# TABLE OF CONTENTS\r\n\r\n- [Module 1: Java Upgrade (Java 8 → 17 → 21)](#module-1)\r\n- [Module 2: Java Internals (Interview Deep Dive)](#module-2)\r\n- [Module 3: Spring Boot Mastery (2.x → 3.x)](#module-3)\r\n- [Module 4: Microservices Architecture](#module-4)\r\n- [Module 5: Database Mastery (Oracle SQL + PostgreSQL)](#module-5)\r\n- [Module 6: Apache Kafka \u0026 Event-Driven Architecture](#module-6)\r\n- [Module 7: API Design \u0026 Communication](#module-7)\r\n- [Module 8: Docker, Kubernetes \u0026 Cloud (AWS)](#module-8)\r\n- [Module 9: System Design](#module-9)\r\n- [Module 10: Low-Level Design (LLD)](#module-10)\r\n- [Module 11: DSA in Java](#module-11)\r\n- [Module 12: AI/LLM Integration for Backend Developers](#module-12)\r\n- [Module 13: Behavioral \u0026 Interview Execution](#module-13)\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-1\"\u003e\u003c/a\u003e\r\n# MODULE 1: Java Upgrade (Java 8 → 17 → 21)\r\n\r\n\u003e **What this module is about:** Java has shipped 6 LTS (Long Term Support) versions since Java 8. Most companies on Java 8 are now migrating to 17 or 21. Interviewers WILL ask \"What\u0027s new since Java 8?\" This module takes you from Java 8 through every important feature up to Java 21.\r\n\r\n---\r\n\r\n## 1.0 Internal Revision — Java 8 Core Concepts\r\n\r\nBefore learning what\u0027s NEW, make sure these Java 8 foundations are rock solid.\r\n\r\n### What is a Lambda Expression?\r\n\r\n**Definition:** A lambda expression is a short, anonymous function (no name, no class) that you can pass as an argument or store in a variable. It implements exactly one abstract method of a functional interface.\r\n\r\n**In plain English:** Instead of writing a whole class just to define one small behavior, you write it inline in one line. Think of it as a shortcut for \"here\u0027s a tiny function, use it.\"\r\n\r\n```java\r\n// BEFORE Java 8 — you needed an anonymous inner class\r\nRunnable r = new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"Hello\");\r\n    }\r\n};\r\n\r\n// JAVA 8 — lambda: same thing, one line\r\nRunnable r = () -\u003e System.out.println(\"Hello\");\r\n\r\n// Lambda with parameters\r\nComparator\u003cString\u003e comp = (a, b) -\u003e a.length() - b.length();\r\n\r\n// Lambda syntax:\r\n// (parameters) -\u003e expression        ← single expression\r\n// (parameters) -\u003e { statements; }   ← block of code\r\n```\r\n\r\n### What is a Functional Interface?\r\n\r\n**Definition:** A functional interface is a Java interface that has exactly ONE abstract method. It can have multiple default or static methods, but only one abstract.\r\n\r\n**In plain English:** It\u0027s the \"shape\" that a lambda must fit into. The lambda provides the body for that single method.\r\n\r\n```java\r\n@FunctionalInterface  // optional but recommended — compiler checks \"only 1 abstract method\"\r\ninterface Calculator {\r\n    int calculate(int a, int b);  // ← the ONLY abstract method\r\n}\r\n\r\nCalculator add = (a, b) -\u003e a + b;\r\nCalculator multiply = (a, b) -\u003e a * b;\r\nSystem.out.println(add.calculate(3, 4));  // 7\r\n```\r\n\r\n**Built-in functional interfaces in java.util.function:**\r\n\r\n| Interface | Input → Output | Example |\r\n|-----------|---------------|---------|\r\n| `Predicate\u003cT\u003e` | T → boolean | `name -\u003e name.length() \u003e 3` |\r\n| `Function\u003cT, R\u003e` | T → R | `user -\u003e user.getName()` |\r\n| `Consumer\u003cT\u003e` | T → void | `msg -\u003e System.out.println(msg)` |\r\n| `Supplier\u003cT\u003e` | () → T | `() -\u003e new Random().nextInt()` |\r\n| `BiFunction\u003cT, U, R\u003e` | (T, U) → R | `(a, b) -\u003e a + b` |\r\n\r\n### What is the Stream API?\r\n\r\n**Definition:** The Stream API is a sequence of elements from a source (collection, array, I/O) that supports aggregate operations (filter, map, reduce) in a declarative pipeline style.\r\n\r\n**In plain English:** Instead of writing `for` loops to filter/transform data, you chain operations like a pipeline: take this list → keep only items matching X → transform each item → collect results. Streams make data processing code cleaner and more readable.\r\n\r\n```java\r\nList\u003cString\u003e names = List.of(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\");\r\n\r\nList\u003cString\u003e result = names.stream()        // create stream from list\r\n    .filter(name -\u003e name.length() \u003e 3)      // keep names longer than 3 chars\r\n    .map(String::toUpperCase)               // convert each to uppercase\r\n    .sorted()                                // sort alphabetically\r\n    .collect(Collectors.toList());           // collect into a new list\r\n// Result: [ALICE, CHARLIE, DAVID]\r\n\r\n// reduce — combine all elements into one value\r\nint sum = List.of(1, 2, 3, 4, 5).stream()\r\n    .reduce(0, Integer::sum);  // 15\r\n\r\n// groupingBy — group elements by some property\r\nMap\u003cInteger, List\u003cString\u003e\u003e byLength = names.stream()\r\n    .collect(Collectors.groupingBy(String::length));\r\n// {3=[Bob, Eve], 5=[Alice, David], 7=[Charlie]}\r\n```\r\n\r\n**Key rule:** Streams are **LAZY** — intermediate operations (filter, map, sorted) don\u0027t run until a **terminal** operation (collect, forEach, reduce) is called.\r\n\r\n### What is Optional?\r\n\r\n**Definition:** Optional\u003cT\u003e is a container that may or may not hold a non-null value. It forces you to explicitly handle the \"absent\" case instead of getting a NullPointerException.\r\n\r\n**In plain English:** Instead of returning null (which crashes your code later), you return Optional. The caller is forced to say \"if present, do X; if absent, do Y.\"\r\n\r\n```java\r\nOptional\u003cString\u003e opt = Optional.ofNullable(getName());  // might be null\r\n\r\nString name = opt.orElse(\"Unknown\");                     // default value\r\nString name = opt.orElseThrow(() -\u003e\r\n    new NotFoundException(\"User not found\"));             // throw if empty\r\nopt.ifPresent(n -\u003e System.out.println(n));               // only if present\r\n\r\n// Chaining — safely navigate nested objects\r\nString city = getUserById(id)\r\n    .map(User::getAddress)\r\n    .map(Address::getCity)\r\n    .orElse(\"Unknown\");\r\n// No NullPointerException even if getAddress() returns null!\r\n```\r\n\r\n**Rule:** Use Optional ONLY for return types. Never for fields, method parameters, or collections.\r\n\r\n### What is CompletableFuture?\r\n\r\n**Definition:** CompletableFuture\u003cT\u003e is an asynchronous computation that will eventually produce a result or an exception. It lets you chain multiple async steps together.\r\n\r\n**In plain English:** You say \"go do this work on another thread, and when it\u0027s done, take the result and do this next thing.\" It\u0027s like ordering food delivery — you don\u0027t stand at the restaurant waiting; you go do other stuff and handle the food when it arrives.\r\n\r\n```java\r\nCompletableFuture\u003cString\u003e future = CompletableFuture\r\n    .supplyAsync(() -\u003e fetchData())        // run in background thread\r\n    .thenApply(data -\u003e process(data))      // when done, process result\r\n    .thenApply(result -\u003e format(result))   // then format\r\n    .exceptionally(ex -\u003e \"Error: \" + ex.getMessage());  // handle errors\r\n\r\n// Combine two independent async calls\r\nCompletableFuture\u003cString\u003e combined = future1.thenCombine(\r\n    future2, (r1, r2) -\u003e r1 + r2);\r\n\r\n// Wait for all to finish\r\nCompletableFuture.allOf(future1, future2, future3).join();\r\n```\r\n\r\n### What are Default Methods in Interfaces?\r\n\r\n**Definition:** Default methods are concrete methods (with a body) inside an interface, marked with the `default` keyword. They were added in Java 8 so interfaces could evolve without breaking existing implementations.\r\n\r\n**In plain English:** Before Java 8, adding a new method to an interface broke every class implementing it. Default methods let you add new methods with a default body — existing classes get the behavior for free and can override if needed.\r\n\r\n```java\r\ninterface Loggable {\r\n    default void log(String message) {\r\n        System.out.println(\"[LOG] \" + message);\r\n    }\r\n}\r\n// Any class implementing Loggable gets log() automatically\r\n```\r\n\r\n### What is the java.time API?\r\n\r\n**Definition:** The java.time package (JSR 310) provides immutable, thread-safe date/time classes that replace the old, buggy `java.util.Date` and `Calendar`.\r\n\r\n```java\r\nLocalDate date = LocalDate.now();                   // 2026-02-13\r\nLocalTime time = LocalTime.now();                   // 14:30:45\r\nLocalDateTime dateTime = LocalDateTime.now();       // 2026-02-13T14:30:45\r\nZonedDateTime zoned = ZonedDateTime.now(ZoneId.of(\"UTC\"));\r\nInstant instant = Instant.now();                    // epoch-based timestamp\r\n\r\nDuration duration = Duration.between(start, end);   // hours/minutes/seconds\r\nPeriod period = Period.between(date1, date2);        // years/months/days\r\n```\r\n\r\n**Rule:** NEVER use `java.util.Date` or `java.util.Calendar` in new code. Always use `java.time.*`.\r\n\r\n---\r\n\r\n## 1.1 Java 9 — Modules, Collection Factory Methods\r\n\r\n### What is the Module System (Project Jigsaw)?\r\n\r\n**Definition:** The Java Platform Module System (JPMS) allows you to organize code into modules — groups of packages with explicit declarations of what they export and what they depend on.\r\n\r\n**In plain English:** Before Java 9, if a class was `public`, ANYONE could use it — even internal classes you didn\u0027t want others to touch. Modules let you say: \"This package is public and available; these other packages are private and internal.\" Think of it like rooms in a house — you choose which rooms guests can enter.\r\n\r\n```java\r\n// module-info.java — the module descriptor\r\nmodule com.myapp.order {\r\n    requires com.myapp.common;       // I depend on this module\r\n    requires java.sql;               // I depend on this JDK module\r\n    exports com.myapp.order.api;     // ONLY this package is visible outside\r\n    // All other packages are HIDDEN from other modules\r\n}\r\n```\r\n\r\n**Interview note:** Most Spring Boot apps don\u0027t use JPMS yet, but interviewers ask about the concept.\r\n\r\n### What are Collection Factory Methods?\r\n\r\n**Definition:** Static factory methods `List.of()`, `Set.of()`, `Map.of()` create immutable (unmodifiable) collections in one line.\r\n\r\n**In plain English:** Before Java 9, creating an unmodifiable list took 2+ lines. Now it\u0027s one line — and the collection is truly immutable (can\u0027t add/remove).\r\n\r\n```java\r\n// Before Java 9\r\nList\u003cString\u003e list = Collections.unmodifiableList(Arrays.asList(\"a\", \"b\", \"c\"));\r\n\r\n// Java 9+\r\nList\u003cString\u003e list = List.of(\"a\", \"b\", \"c\");\r\nSet\u003cInteger\u003e set = Set.of(1, 2, 3);\r\nMap\u003cString, Integer\u003e map = Map.of(\"a\", 1, \"b\", 2);\r\n\r\n// IMMUTABLE — calling list.add(\"d\") throws UnsupportedOperationException\r\n```\r\n\r\n### What is JShell?\r\n\r\n**Definition:** JShell is a REPL (Read-Eval-Print Loop) — an interactive command-line tool for quickly testing Java expressions without creating files or classes.\r\n\r\n```\r\n$ jshell\r\njshell\u003e int x = 42;\r\njshell\u003e List.of(1, 2, 3).stream().filter(n -\u003e n \u003e 1).toList()\r\n$2 ==\u003e [2, 3]\r\n```\r\n\r\n### What are Private Methods in Interfaces?\r\n\r\n**Definition:** Java 9 allows private methods inside interfaces. They\u0027re helper methods for default methods to avoid code duplication — not accessible to implementing classes.\r\n\r\n```java\r\ninterface Validator {\r\n    default void validateName(String name) { checkNotEmpty(name, \"Name\"); }\r\n    default void validateEmail(String email) { checkNotEmpty(email, \"Email\"); }\r\n    private void checkNotEmpty(String value, String field) {\r\n        if (value == null || value.isBlank())\r\n            throw new IllegalArgumentException(field + \" is empty\");\r\n    }\r\n}\r\n```\r\n\r\n### Interview Q: \"What was the biggest change in Java 9?\"\r\n**Answer:** The Module System (Project Jigsaw) for strong encapsulation at the module level, and collection factory methods (`List.of()`, `Set.of()`, `Map.of()`) for creating immutable collections concisely.\r\n\r\n---\r\n\r\n## 1.2 Java 10 — Local Variable Type Inference (`var`)\r\n\r\n### What is `var`?\r\n\r\n**Definition:** `var` is a keyword for local variable type inference. Instead of writing the type explicitly, you let the compiler figure it out from the right side of the assignment.\r\n\r\n**In plain English:** If the type is obvious from the initializer, you don\u0027t need to write it twice. The compiler is smart enough to know that `new HashMap\u003cString, List\u003cString\u003e\u003e()` returns a `HashMap\u003cString, List\u003cString\u003e\u003e`.\r\n\r\n```java\r\n// Before Java 10\r\nMap\u003cString, List\u003cString\u003e\u003e userGroups = new HashMap\u003cString, List\u003cString\u003e\u003e();\r\n\r\n// Java 10+\r\nvar userGroups = new HashMap\u003cString, List\u003cString\u003e\u003e();  // compiler infers the type\r\nvar list = List.of(\"a\", \"b\", \"c\");                     // inferred as List\u003cString\u003e\r\nvar reader = new BufferedReader(new FileReader(\"f.txt\"));\r\n```\r\n\r\n**Rules for `var`:**\r\n- ONLY for local variables with initializers\r\n- NOT allowed for: method parameters, return types, class fields, `var` without initializer\r\n\r\n**When to use:**\r\n```java\r\n// GOOD — type obvious from right side\r\nvar users = new ArrayList\u003cUser\u003e();\r\nvar mapper = new ObjectMapper();\r\n\r\n// BAD — type not obvious, hurts readability\r\nvar result = getResult();  // What type? Unclear.\r\n```\r\n\r\n### Interview Q: \"Does `var` make Java dynamically typed?\"\r\n**Answer:** No. Java with `var` is still statically typed. The type is inferred at compile time and cannot change afterward. `var x = \"hello\"; x = 42;` won\u0027t compile.\r\n\r\n---\r\n\r\n## 1.3 Java 11 (LTS) — String Methods, HttpClient, Single-File Execution\r\n\r\n### What is an LTS Version?\r\n\r\n**Definition:** LTS (Long-Term Support) means this version gets extended security and bug-fix updates for years. Non-LTS versions only get updates for 6 months.\r\n\r\n**In plain English:** LTS versions are the \"stable\" ones companies trust for production. The LTS versions you need to know: **8, 11, 17, 21**.\r\n\r\n### New String Methods (Java 11)\r\n\r\n| Method | What it does | Example |\r\n|--------|-------------|---------|\r\n| `strip()` | Removes leading/trailing whitespace (Unicode-aware) | `\"  hi  \".strip()` → `\"hi\"` |\r\n| `stripLeading()` | Remove only leading whitespace | `\"  hi  \".stripLeading()` → `\"hi  \"` |\r\n| `stripTrailing()` | Remove only trailing whitespace | `\"  hi  \".stripTrailing()` → `\"  hi\"` |\r\n| `isBlank()` | True if empty or only whitespace | `\"  \".isBlank()` → `true` |\r\n| `repeat(n)` | Repeat the string n times | `\"ha\".repeat(3)` → `\"hahaha\"` |\r\n| `lines()` | Split by line breaks → `Stream\u003cString\u003e` | `\"a\\nb\\nc\".lines()` → stream of 3 |\r\n\r\n**strip() vs trim():** `strip()` is Unicode-aware (handles all whitespace characters). `trim()` only handles ASCII whitespace. Always prefer `strip()` in new code.\r\n\r\n### What is the Java HttpClient?\r\n\r\n**Definition:** `java.net.http.HttpClient` is a built-in HTTP client that supports HTTP/1.1, HTTP/2, synchronous and asynchronous requests. It replaces the need for Apache HttpClient for simple use cases.\r\n\r\n```java\r\nHttpClient client = HttpClient.newHttpClient();\r\n\r\nHttpRequest request = HttpRequest.newBuilder()\r\n    .uri(URI.create(\"https://api.example.com/users\"))\r\n    .header(\"Content-Type\", \"application/json\")\r\n    .GET()\r\n    .build();\r\n\r\n// Synchronous\r\nHttpResponse\u003cString\u003e response = client.send(request, HttpResponse.BodyHandlers.ofString());\r\nSystem.out.println(response.statusCode());  // 200\r\nSystem.out.println(response.body());        // JSON string\r\n\r\n// Asynchronous\r\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\r\n    .thenApply(HttpResponse::body)\r\n    .thenAccept(System.out::println);\r\n```\r\n\r\n### Other Java 11 Changes\r\n- `var` in lambda: `(@NotNull var x, var y) -\u003e x + y`\r\n- `Optional.isEmpty()` — opposite of `isPresent()`\r\n- `Files.readString(path)` / `Files.writeString(path, content)` — one-liner file I/O\r\n\r\n---\r\n\r\n## 1.4 Java 14 — Records, Switch Expressions, Helpful NPE\r\n\r\n### What is a Record?\r\n\r\n**Definition:** A Record is a special class designed to be a transparent, immutable data carrier. It automatically generates the constructor, getters, `equals()`, `hashCode()`, and `toString()`.\r\n\r\n**In plain English:** When you create a class that just holds data (a DTO, a value object), you normally write ~30 lines of boilerplate (fields, constructor, getters, equals, hashCode, toString). A Record does ALL of this in ONE line.\r\n\r\n```java\r\n// BEFORE Records — 30+ lines of boilerplate\r\npublic class User {\r\n    private final String name;\r\n    private final int age;\r\n    public User(String name, int age) { this.name = name; this.age = age; }\r\n    public String getName() { return name; }\r\n    public int getAge() { return age; }\r\n    @Override public boolean equals(Object o) { /* ... */ }\r\n    @Override public int hashCode() { /* ... */ }\r\n    @Override public String toString() { /* ... */ }\r\n}\r\n\r\n// WITH Records — ONE LINE\r\npublic record User(String name, int age) {}\r\n\r\n// What you get automatically:\r\n// - Constructor: new User(\"Alice\", 30)\r\n// - Getters: user.name(), user.age()  (NOT getName() — no \"get\" prefix!)\r\n// - equals(): two Users are equal if all fields are equal\r\n// - hashCode(): based on all fields\r\n// - toString(): User[name=Alice, age=30]\r\n// - Fields are FINAL (immutable)\r\n\r\n// Custom validation in records:\r\npublic record User(String name, int age) {\r\n    public User {  // compact constructor — runs before field assignment\r\n        if (age \u003c 0) throw new IllegalArgumentException(\"Age can\u0027t be negative\");\r\n        name = name.trim();\r\n    }\r\n}\r\n```\r\n\r\n**When to use:**\r\n- DTOs, API request/response bodies, value objects, any \"just holds data\" class\r\n- NOT for JPA entities (JPA needs no-arg constructor + setters)\r\n- NOT for classes with mutable state\r\n\r\n### What is a Switch Expression?\r\n\r\n**Definition:** A switch expression is an enhanced switch that returns a value, uses arrow syntax (`-\u003e`), and has NO fall-through (no `break` needed).\r\n\r\n**In plain English:** Old switch was a statement (does something). New switch is an expression (returns a value). It\u0027s also safer — no accidental fall-through bugs.\r\n\r\n```java\r\n// OLD switch — statement, fall-through risk, verbose\r\nswitch (day) {\r\n    case MONDAY:\r\n    case FRIDAY:\r\n        System.out.println(\"Work\");\r\n        break;  // forget this → fall-through bug!\r\n    case SATURDAY:\r\n        System.out.println(\"Rest\");\r\n        break;\r\n}\r\n\r\n// NEW switch — expression, returns value, no fall-through\r\nString result = switch (day) {\r\n    case MONDAY, FRIDAY -\u003e \"Work\";\r\n    case SATURDAY, SUNDAY -\u003e \"Rest\";\r\n    default -\u003e \"Unknown\";\r\n};\r\n\r\n// With blocks (use yield to return value)\r\nint numLetters = switch (day) {\r\n    case MONDAY, FRIDAY, SUNDAY -\u003e 6;\r\n    case TUESDAY -\u003e 7;\r\n    default -\u003e {\r\n        String s = day.toString();\r\n        yield s.length();  // yield = return for switch blocks\r\n    }\r\n};\r\n```\r\n\r\n### What are Helpful NullPointerExceptions?\r\n\r\n**Definition:** Starting Java 14, JVM tells you exactly WHICH reference was null in a NullPointerException message.\r\n\r\n```java\r\nuser.getAddress().getCity().toUpperCase();\r\n// Before: NullPointerException (which one was null?!)\r\n// Java 14+: NullPointerException: Cannot invoke \"Address.getCity()\"\r\n//           because the return value of \"User.getAddress()\" is null\r\n```\r\n\r\n---\r\n\r\n## 1.5 Java 15 — Text Blocks\r\n\r\n### What is a Text Block?\r\n\r\n**Definition:** A text block is a multi-line string literal delimited by triple quotes (`\"\"\"`). It preserves formatting and eliminates the need for escape characters and concatenation.\r\n\r\n**In plain English:** Writing multi-line strings (JSON, SQL, HTML) used to be messy with `\\n` and `+`. Text blocks let you write them naturally, exactly as they look.\r\n\r\n```java\r\n// BEFORE — messy concatenation\r\nString json = \"{\\n\" +\r\n    \"  \\\"name\\\": \\\"Alice\\\",\\n\" +\r\n    \"  \\\"age\\\": 30\\n\" +\r\n    \"}\";\r\n\r\n// JAVA 15+ — text block (clean, readable)\r\nString json = \"\"\"\r\n    {\r\n      \"name\": \"Alice\",\r\n      \"age\": 30\r\n    }\r\n    \"\"\";\r\n\r\n// Great for SQL\r\nString sql = \"\"\"\r\n    SELECT u.name, u.email\r\n    FROM users u\r\n    JOIN orders o ON u.id = o.user_id\r\n    WHERE o.status = \u0027ACTIVE\u0027\r\n    ORDER BY u.name\r\n    \"\"\";\r\n\r\n// String interpolation with formatted()\r\nString html = \"\"\"\r\n    \u003chtml\u003e\r\n        \u003cbody\u003e\u003ch1\u003eHello, %s\u003c/h1\u003e\u003c/body\u003e\r\n    \u003c/html\u003e\r\n    \"\"\".formatted(name);\r\n```\r\n\r\n---\r\n\r\n## 1.6 Java 16 — Pattern Matching for `instanceof`\r\n\r\n### What is Pattern Matching for instanceof?\r\n\r\n**Definition:** Pattern matching for `instanceof` combines the type check and the cast into a single expression — eliminating the redundant cast line.\r\n\r\n**In plain English:** Before, you checked `if (obj instanceof String)` and then separately cast `(String) obj`. Now you do both in one step.\r\n\r\n```java\r\n// BEFORE — check, then cast separately\r\nif (obj instanceof String) {\r\n    String s = (String) obj;\r\n    System.out.println(s.length());\r\n}\r\n\r\n// JAVA 16+ — pattern matching: check + bind variable in one step\r\nif (obj instanceof String s) {\r\n    System.out.println(s.length());  // s is already a String!\r\n}\r\n\r\n// Works with \u0026\u0026\r\nif (obj instanceof String s \u0026\u0026 s.length() \u003e 5) {\r\n    System.out.println(s.toUpperCase());\r\n}\r\n\r\n// Cleaner equals():\r\n@Override\r\npublic boolean equals(Object o) {\r\n    return o instanceof User other\r\n        \u0026\u0026 this.name.equals(other.name)\r\n        \u0026\u0026 this.age == other.age;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 1.7 Java 17 (LTS) — Sealed Classes\r\n\r\n### What is a Sealed Class?\r\n\r\n**Definition:** A sealed class or interface restricts which other classes can extend or implement it. Only the explicitly permitted subclasses are allowed.\r\n\r\n**In plain English:** Normally, any class can extend your class. With `sealed`, you say \"ONLY these specific classes can extend me — nobody else.\" This lets the compiler guarantee exhaustive checks in switch.\r\n\r\n```java\r\n// Only Circle, Rectangle, Triangle can implement Shape\r\npublic sealed interface Shape permits Circle, Rectangle, Triangle {}\r\n\r\npublic record Circle(double radius) implements Shape {}\r\npublic record Rectangle(double width, double height) implements Shape {}\r\npublic final class Triangle implements Shape { /* ... */ }\r\n\r\n// Compiler knows ALL possible Shape types:\r\ndouble area = switch (shape) {\r\n    case Circle c    -\u003e Math.PI * c.radius() * c.radius();\r\n    case Rectangle r -\u003e r.width() * r.height();\r\n    case Triangle t  -\u003e calculateTriangleArea(t);\r\n    // No default needed! Compiler knows all cases are covered.\r\n};\r\n```\r\n\r\n**When to use:**\r\n- Domain models with a fixed set of variants (Payment types, API response types, Order statuses)\r\n- Enables exhaustive pattern matching (no `default` case needed)\r\n\r\n### Java 8 → 17 Feature Summary\r\n\r\n| Version | Key Feature | One-Liner |\r\n|---------|-------------|-----------|\r\n| 9  | Modules, `List.of()` | Encapsulation at module level; immutable collections |\r\n| 10 | `var` | Type inference for local variables |\r\n| 11 (LTS) | `strip()`, `HttpClient` | Better string methods; built-in HTTP client |\r\n| 14 | Records, switch expressions | Immutable data classes in one line; switch returns values |\r\n| 15 | Text blocks `\"\"\"` | Multi-line strings without escape mess |\r\n| 16 | Pattern matching `instanceof` | Combine type check + cast in one step |\r\n| 17 (LTS) | Sealed classes | Restrict who can extend your class |\r\n\r\n---\r\n\r\n## 1.8 Java 21 (LTS) — Virtual Threads, Pattern Matching for Switch\r\n\r\n### What are Virtual Threads (Project Loom)?\r\n\r\n**Definition:** Virtual threads are lightweight threads managed by the JVM (not the OS). They\u0027re cheap to create (few KB vs 1 MB for platform threads) and cheap to block. When a virtual thread blocks on I/O, the underlying carrier thread is released to run other virtual threads.\r\n\r\n**In plain English:** Traditional Java servers use 1 OS thread per request. Each thread costs ~1 MB of memory and is managed by the operating system. So a server with 200 threads can only handle 200 concurrent requests. Virtual threads are like \"fake\" threads inside the JVM — you can create millions of them, and when one waits on a database or HTTP call, it doesn\u0027t waste a real thread. Think of it like a restaurant where one waiter (carrier thread) serves 100 tables (virtual threads) by moving to the next table whenever one is waiting for food.\r\n\r\n```java\r\n// Creating virtual threads\r\nThread.ofVirtual().start(() -\u003e {\r\n    System.out.println(\"Running in virtual thread: \" + Thread.currentThread());\r\n});\r\n\r\n// ExecutorService with virtual threads — 100K concurrent tasks!\r\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\r\n    for (int i = 0; i \u003c 100_000; i++) {\r\n        executor.submit(() -\u003e {\r\n            Thread.sleep(Duration.ofSeconds(1));  // blocking is FINE — releases carrier thread\r\n            return fetchDataFromDB();\r\n        });\r\n    }\r\n}\r\n\r\n// Spring Boot 3.2+ — enable virtual threads with ONE property:\r\n// application.yml:\r\n// spring:\r\n//   threads:\r\n//     virtual:\r\n//       enabled: true\r\n// That\u0027s it! All request-handling threads become virtual.\r\n```\r\n\r\n**Why this is the biggest change since Java 8:**\r\n- Before: 200-500 platform threads = 200-500 concurrent requests max\r\n- After: Millions of virtual threads = unlimited concurrency\r\n- You get the scalability of reactive programming (WebFlux) with simple blocking code\r\n- No need to learn Mono/Flux for most use cases\r\n\r\n### What are Sequenced Collections?\r\n\r\n**Definition:** New interfaces (`SequencedCollection`, `SequencedSet`, `SequencedMap`) that provide a uniform API to access the first/last element and get a reversed view for ordered collections.\r\n\r\n**In plain English:** Before Java 21, getting the first/last element was different for every collection: `list.get(0)` vs `deque.getFirst()` vs `sortedSet.first()`. Now they all have `getFirst()` and `getLast()`.\r\n\r\n```java\r\nSequencedCollection\u003cString\u003e list = new ArrayList\u003c\u003e(List.of(\"a\", \"b\", \"c\"));\r\nlist.getFirst();    // \"a\"\r\nlist.getLast();     // \"c\"\r\nlist.addFirst(\"z\");\r\nlist.reversed();    // reversed view of the list\r\n```\r\n\r\n### What is Pattern Matching for Switch?\r\n\r\n**Definition:** Switch can now match on types, records, null, and guard conditions — not just constants.\r\n\r\n```java\r\nsealed interface Shape permits Circle, Rectangle {}\r\nrecord Circle(double radius) implements Shape {}\r\nrecord Rectangle(double w, double h) implements Shape {}\r\n\r\nString describe(Shape shape) {\r\n    return switch (shape) {\r\n        case Circle c when c.radius() \u003e 10 -\u003e \"Large circle\";\r\n        case Circle c -\u003e \"Small circle with radius \" + c.radius();\r\n        case Rectangle r when r.w() == r.h() -\u003e \"Square with side \" + r.w();\r\n        case Rectangle r -\u003e \"Rectangle \" + r.w() + \"x\" + r.h();\r\n    };\r\n}\r\n\r\n// Can also match null\r\nString format(Object obj) {\r\n    return switch (obj) {\r\n        case null      -\u003e \"null\";\r\n        case Integer i -\u003e \"Integer: \" + i;\r\n        case String s  -\u003e \"String: \" + s;\r\n        default        -\u003e \"Other: \" + obj;\r\n    };\r\n}\r\n```\r\n\r\n### What are Record Patterns (Deconstruction)?\r\n\r\n**Definition:** Record patterns let you extract (deconstruct) the components of a record directly in `instanceof` or `switch`, including nested records.\r\n\r\n```java\r\nrecord Point(int x, int y) {}\r\nrecord Line(Point start, Point end) {}\r\n\r\nif (line instanceof Line(Point(var x1, var y1), Point(var x2, var y2))) {\r\n    double length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n}\r\n```\r\n\r\n### Interview Q: \"What are virtual threads and how do they differ from platform threads?\"\r\n**Answer:** Virtual threads are lightweight threads managed by the JVM, costing only a few KB (vs 1 MB for platform threads). When a virtual thread blocks on I/O, the carrier thread is released to run other virtual threads. This allows millions of concurrent tasks without reactive programming. In Spring Boot 3.2+, enable with `spring.threads.virtual.enabled=true`.\r\n\r\n---\r\n\r\n## 1.9 Migration Guide: Java 8 → 17 → 21\r\n\r\n### Step 1: Java 8 → 17\r\n\r\n| What Changes | Action Required |\r\n|-------------|----------------|\r\n| `javax.*` packages | JAXB, JAX-WS removed from JDK — add as Maven dependencies |\r\n| Removed APIs | `sun.misc.Unsafe` restricted, Nashorn JS engine removed |\r\n| Build tools | Maven: `maven-compiler-plugin` 3.10+, `\u003crelease\u003e17\u003c/release\u003e` |\r\n| JVM flags | G1GC is default. Remove deprecated flags like `-XX:+UseConcMarkSweepGC` |\r\n| Reflection | Strong encapsulation — `--add-opens` may be needed for frameworks using reflection on JDK internals |\r\n| Testing | Upgrade JUnit 4 → JUnit 5 |\r\n\r\n### Step 2: Java 17 → 21\r\n\r\n| What Changes | Action Required |\r\n|-------------|----------------|\r\n| Virtual threads | Enable: `spring.threads.virtual.enabled=true` |\r\n| Thread-locals | May behave differently with virtual threads (different carrier) |\r\n| `finalize()` | Deprecated for removal. Use `try-with-resources` or `Cleaner` |\r\n| Preview features | Some now final — remove `--enable-preview` flag |\r\n\r\n### Maven Configuration for Java 21\r\n```xml\r\n\u003cproperties\u003e\r\n    \u003cjava.version\u003e21\u003c/java.version\u003e\r\n    \u003cmaven.compiler.source\u003e21\u003c/maven.compiler.source\u003e\r\n    \u003cmaven.compiler.target\u003e21\u003c/maven.compiler.target\u003e\r\n\u003c/properties\u003e\r\n```\r\n\r\n---\r\n\r\n## 1.10 ✅ What You\u0027ve Learnt After Module 1\r\n\r\nAfter completing this module, you can now confidently:\r\n\r\n1. **Answer \"What\u0027s new since Java 8?\"** — the #1 most common Java interview question\r\n2. **Define and explain Records** — immutable data classes, when to use vs not (JPA)\r\n3. **Define and explain Sealed Classes** — restricted hierarchies + exhaustive switch\r\n4. **Define and explain Virtual Threads** — JVM-managed lightweight threads, paradigm shift\r\n5. **Use modern syntax** — `var`, text blocks, switch expressions, pattern matching\r\n6. **Plan a migration** from Java 8 → 17 → 21 with a checklist of breaking changes\r\n7. **Demonstrate** that you\u0027re modern, not stuck on Java 8\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-2\"\u003e\u003c/a\u003e\r\n# MODULE 2: Java Internals (Interview Deep Dive)\r\n\r\n\u003e **What this module is about:** Interviewers love to dig into the internals — how HashMap works, what happens in JVM memory, how garbage collection works, how multithreading really behaves. This module makes you fluent in all of it.\r\n\r\n---\r\n\r\n## 2.0 Internal Revision — OOP, Strings, Exceptions\r\n\r\n### What is OOP (Object-Oriented Programming)?\r\n\r\n**Definition:** OOP is a programming paradigm where software is structured around OBJECTS — bundles of state (fields) and behavior (methods) — rather than functions and logic alone.\r\n\r\n**The 4 Pillars:**\r\n\r\n**1. Encapsulation:** Hide internal state, expose only what\u0027s necessary through methods.\r\n\r\n```java\r\npublic class BankAccount {\r\n    private double balance;  // hidden — outsiders can\u0027t directly set balance\r\n    public void deposit(double amount) {\r\n        if (amount \u003e 0) this.balance += amount;  // controlled access\r\n    }\r\n    public double getBalance() { return balance; }\r\n}\r\n```\r\n\r\n**2. Inheritance:** A child class inherits fields and methods from a parent class, extending its behavior.\r\n\r\n```java\r\npublic class SavingsAccount extends BankAccount {\r\n    private double interestRate;\r\n    public void applyInterest() {\r\n        deposit(getBalance() * interestRate);\r\n    }\r\n}\r\n```\r\n\r\n**3. Polymorphism:** The same method behaves differently depending on the actual object type at runtime.\r\n\r\n```java\r\nBankAccount account = new SavingsAccount(); // reference is BankAccount, object is SavingsAccount\r\naccount.deposit(100); // calls SavingsAccount\u0027s version if overridden\r\n```\r\n\r\n**4. Abstraction:** Hide complex implementation behind simple interfaces.\r\n\r\n```java\r\npublic abstract class Shape {\r\n    abstract double area();      // subclasses MUST implement\r\n    public void printArea() {    // concrete method — shared behavior\r\n        System.out.println(\"Area: \" + area());\r\n    }\r\n}\r\n```\r\n\r\n### Abstract Class vs Interface — When to Use Which?\r\n\r\n| Feature | Abstract Class | Interface |\r\n|---------|---------------|-----------|\r\n| Can have state (fields) | Yes | No (only constants) |\r\n| Can have constructors | Yes | No |\r\n| Inheritance | Single only (`extends`) | Multiple (`implements`) |\r\n| When to use | Shared state + behavior among related classes | Define a contract/capability |\r\n| Example | `Animal` (shared fields like `name`, `age`) | `Serializable`, `Comparable`, `Runnable` |\r\n\r\n### What is String Immutability?\r\n\r\n**Definition:** Strings in Java are immutable — once created, the characters cannot be changed. Every \"modification\" creates a NEW String object.\r\n\r\n**Why it matters:** String immutability enables the String Pool (memory optimization), thread safety, and security (strings are used for passwords, URLs, class names).\r\n\r\n```java\r\nString s1 = \"hello\";\r\nString s2 = \"hello\";\r\nString s3 = new String(\"hello\");\r\n\r\ns1 == s2;       // true — same reference from String Pool\r\ns1 == s3;       // false — s3 is a new object on heap\r\ns1.equals(s3);  // true — content comparison\r\n\r\nString s = \"hello\";\r\ns.concat(\" world\");  // creates NEW string, s is STILL \"hello\"\r\ns = s.concat(\" world\");  // now s points to \"hello world\"\r\n\r\n// For frequent modifications: StringBuilder (not thread-safe, faster)\r\n//                             StringBuffer  (thread-safe, slower)\r\n```\r\n\r\n### What is the Exception Hierarchy?\r\n\r\n**Definition:** Java\u0027s exception system is a class hierarchy under `Throwable`.\r\n\r\n```\r\nThrowable\r\n├── Error (don\u0027t catch — JVM problems)\r\n│   ├── OutOfMemoryError\r\n│   └── StackOverflowError\r\n└── Exception\r\n    ├── Checked Exceptions (MUST handle with try-catch or throws)\r\n    │   ├── IOException\r\n    │   └── SQLException\r\n    └── RuntimeException (Unchecked — optional to handle)\r\n        ├── NullPointerException\r\n        ├── IllegalArgumentException\r\n        └── ArrayIndexOutOfBoundsException\r\n```\r\n\r\n**Rule:**\r\n- Checked exceptions = problems you should anticipate and handle (file not found, network error)\r\n- Unchecked exceptions = programming bugs (null access, bad argument)\r\n\r\n---\r\n\r\n## 2.1 HashMap Internals\r\n\r\n\u003e **This is the #1 most asked Java interview question. Know it cold.**\r\n\r\n### What is a HashMap?\r\n\r\n**Definition:** HashMap\u003cK, V\u003e is a key-value data structure that stores entries in an array of buckets. It uses the key\u0027s `hashCode()` to determine which bucket to store in, giving average O(1) time for get/put operations.\r\n\r\n**In plain English:** Think of a library with numbered shelves (buckets). When you add a book, you calculate a \"shelf number\" from the book\u0027s title (hashCode). To find a book, you calculate the shelf number from the title and go straight to that shelf — instead of searching every shelf.\r\n\r\n### How HashMap Works — Step by Step\r\n\r\n```\r\nHashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e();\r\nmap.put(\"Alice\", 25);\r\n\r\nStep 1: HASH — Calculate bucket index\r\n  hashCode = \"Alice\".hashCode()  → some integer (e.g., 92082440)\r\n  hash = hashCode ^ (hashCode \u003e\u003e\u003e 16)  // spread bits to reduce collisions\r\n  index = hash \u0026 (capacity - 1)  // if capacity=16, index is 0-15\r\n\r\nStep 2: STORE — Put into the bucket\r\n  If bucket is EMPTY → create Node(hash, key, value, next=null)\r\n  If bucket has existing entries → walk the linked list:\r\n    • If key.equals(existingKey) → REPLACE value\r\n    • If no match → APPEND new node to the end\r\n\r\nStep 3: TREEIFY (Java 8+)\r\n  If a bucket\u0027s linked list grows to 8+ nodes → convert to Red-Black Tree\r\n  (lookup becomes O(log n) instead of O(n))\r\n  If tree shrinks below 6 → convert back to linked list\r\n```\r\n\r\n**Visual:**\r\n```\r\nBucket Array (capacity = 16)\r\n[0] → null\r\n[1] → Node(\"Alice\",25) → Node(\"Bob\",30) → null    ← linked list (collision)\r\n[2] → null\r\n[3] → Node(\"Charlie\",35) → null\r\n...\r\n[7] → TreeNode → TreeNode → ...   ← red-black tree (8+ collisions)\r\n...\r\n[15] → null\r\n```\r\n\r\n### What is Load Factor and Resizing?\r\n\r\n**Definition:** Load factor (default 0.75) is the threshold that triggers resizing. When the map is 75% full, it doubles the capacity and rehashes all entries.\r\n\r\n**In plain English:** When the map gets too crowded (too many collisions), it creates a bigger array (2x) and moves all entries to their new positions. This is O(n) — expensive. If you know the size upfront, set the initial capacity: `new HashMap\u003c\u003e(1000)`.\r\n\r\n### What is the equals/hashCode Contract?\r\n\r\n**Definition:** Two objects that are `equals()` MUST have the same `hashCode()`. Violating this contract breaks HashMap — you can put a key in but never find it again.\r\n\r\n```java\r\n// BROKEN — missing hashCode()\r\nclass User {\r\n    String name;\r\n    @Override public boolean equals(Object o) {\r\n        return o instanceof User u \u0026\u0026 this.name.equals(u.name);\r\n    }\r\n    // hashCode NOT overridden → uses default (memory address)\r\n    // Two equal Users might hash to DIFFERENT buckets!\r\n    // map.get(user) returns null even though user is in the map!\r\n}\r\n\r\n// CORRECT — always override both together\r\n@Override public boolean equals(Object o) {\r\n    return o instanceof User u \u0026\u0026 this.name.equals(u.name);\r\n}\r\n@Override public int hashCode() {\r\n    return Objects.hash(name);\r\n}\r\n```\r\n\r\n### Interview Q: \"How does HashMap handle collisions?\"\r\n**Answer:** Separate chaining. Each bucket is a linked list. When two keys hash to the same bucket, the new entry is appended to the list. In Java 8+, if the list grows to 8+ nodes, it converts to a red-black tree (O(log n) lookup). If the tree shrinks below 6, it converts back to a linked list.\r\n\r\n---\r\n\r\n## 2.2 ConcurrentHashMap\r\n\r\n### What is ConcurrentHashMap?\r\n\r\n**Definition:** ConcurrentHashMap is a thread-safe HashMap that uses fine-grained locking (per-bucket synchronization) instead of locking the entire map, allowing high concurrency.\r\n\r\n**In plain English:** Regular HashMap is NOT safe to use from multiple threads — two threads writing at the same time can corrupt the internal data. ConcurrentHashMap fixes this by locking only the individual bucket being accessed, not the whole map. So multiple threads can read/write DIFFERENT buckets simultaneously.\r\n\r\n```java\r\n// WRONG — HashMap is NOT thread-safe\r\nMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e();  // two threads writing → corruption!\r\n\r\n// Option 1 (slow): synchronizedMap — locks ENTIRE map on every operation\r\nMap\u003cString, Integer\u003e syncMap = Collections.synchronizedMap(new HashMap\u003c\u003e());\r\n\r\n// Option 2 (fast): ConcurrentHashMap — locks only the affected bucket\r\nConcurrentHashMap\u003cString, Integer\u003e map = new ConcurrentHashMap\u003c\u003e();\r\n\r\n// Atomic operations (thread-safe compound operations):\r\nmap.putIfAbsent(\"key\", 1);                           // put only if key doesn\u0027t exist\r\nmap.computeIfAbsent(\"key\", k -\u003e expensiveCalc(k));   // compute if absent\r\nmap.merge(\"key\", 1, Integer::sum);                    // atomic increment\r\n```\r\n\r\n**GOTCHA:** ConcurrentHashMap does NOT allow null keys or null values. HashMap allows one null key and multiple null values.\r\n\r\n### When to Use What\r\n| Implementation | Thread-safe? | Performance | Use When |\r\n|---------------|-------------|-------------|----------|\r\n| HashMap | No | Fastest | Single-threaded code |\r\n| ConcurrentHashMap | Yes | Fast | Multi-threaded code (preferred) |\r\n| synchronizedMap | Yes | Slow | Almost never (use ConcurrentHashMap) |\r\n| Hashtable | Yes | Slowest | NEVER (legacy, fully synchronized) |\r\n\r\n---\r\n\r\n## 2.3 Collections Framework Deep Dive\r\n\r\n### ArrayList vs LinkedList\r\n\r\n**Definition:**\r\n- **ArrayList** — backed by a resizable array. Random access is O(1).\r\n- **LinkedList** — a doubly-linked list. Access by index traverses from the head and is O(n).\r\n\r\n| Operation | ArrayList | LinkedList |\r\n|-----------|-----------|------------|\r\n| Get by index | O(1) — direct array access | O(n) — traverse from head |\r\n| Add at end | O(1) amortized | O(1) |\r\n| Add at middle | O(n) — shift elements | O(1) if you have the node ref (but finding it is O(n)) |\r\n| Memory | Compact, cache-friendly | Extra overhead per node (prev + next pointers) |\r\n\r\n**Bottom line:** Use ArrayList 99% of the time. LinkedList is rarely better in practice.\r\n\r\n### TreeMap vs HashMap\r\n\r\n| Feature | HashMap | TreeMap |\r\n|---------|---------|--------|\r\n| Time complexity | O(1) average | O(log n) — Red-Black Tree |\r\n| Ordering | No ordering | SORTED by key |\r\n| Null keys | Allows one null key | No null keys |\r\n| Extra methods | — | `floorKey()`, `ceilingKey()`, `subMap()`, `firstKey()`, `lastKey()` |\r\n| Use when | You need fast lookups | You need sorted keys or range queries |\r\n\r\n### What are Fail-Fast vs Fail-Safe Iterators?\r\n\r\n**Definition:**\r\n- **Fail-Fast:** Throws `ConcurrentModificationException` if the collection is modified during iteration.\r\n- **Fail-Safe:** Iterates over a snapshot/copy — modifications during iteration don\u0027t affect the iterator.\r\n\r\n```java\r\n// FAIL-FAST (ArrayList, HashMap, HashSet)\r\nList\u003cString\u003e list = new ArrayList\u003c\u003e(List.of(\"a\", \"b\", \"c\"));\r\nfor (String s : list) {\r\n    list.remove(s);  // ConcurrentModificationException!\r\n}\r\n\r\n// Fix: use Iterator.remove()\r\nIterator\u003cString\u003e it = list.iterator();\r\nwhile (it.hasNext()) {\r\n    if (it.next().equals(\"b\")) it.remove();  // safe\r\n}\r\n\r\n// FAIL-SAFE (CopyOnWriteArrayList, ConcurrentHashMap)\r\nCopyOnWriteArrayList\u003cString\u003e cowList = new CopyOnWriteArrayList\u003c\u003e(List.of(\"a\", \"b\"));\r\nfor (String s : cowList) {\r\n    cowList.add(\"c\");  // no exception — iterates over a snapshot\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2.4 JVM Architecture\r\n\r\n### What is the JVM?\r\n\r\n**Definition:** The Java Virtual Machine (JVM) is a runtime engine that executes Java bytecode. It provides memory management, garbage collection, security, and platform independence. Your `.java` file is compiled to `.class` bytecode, which the JVM interprets and JIT-compiles to native machine code.\r\n\r\n```\r\n┌─────────────────────────────────────────────────┐\r\n│                  JVM Architecture                │\r\n├─────────────────────────────────────────────────┤\r\n│  1. ClassLoader Subsystem                        │\r\n│     Load .class files → verify → prepare         │\r\n│                                                  │\r\n│  2. Runtime Data Areas                           │\r\n│     ┌──────────┐  ┌───────────┐                  │\r\n│     │   HEAP   │  │   STACK   │ (per thread)     │\r\n│     │ (objects)│  │  (frames) │                  │\r\n│     └──────────┘  └───────────┘                  │\r\n│     ┌──────────┐  ┌───────────┐                  │\r\n│     │ Metaspace│  │PC Register│ (per thread)     │\r\n│     │(classes) │  └───────────┘                  │\r\n│     └──────────┘                                 │\r\n│                                                  │\r\n│  3. Execution Engine                             │\r\n│     Interpreter → JIT Compiler → GC              │\r\n└─────────────────────────────────────────────────┘\r\n```\r\n\r\n### What is the ClassLoader?\r\n\r\n**Definition:** The ClassLoader is the subsystem that loads `.class` files into the JVM. It follows a delegation hierarchy:\r\n\r\n```\r\nBootstrap ClassLoader    → JDK core classes (java.lang.*, java.util.*)\r\n  ↓\r\nPlatform ClassLoader     → platform-specific classes (java.sql.*, javax.*)\r\n  ↓\r\nApplication ClassLoader  → YOUR application classes from classpath\r\n  ↓\r\nCustom ClassLoaders      → e.g., Tomcat\u0027s WebAppClassLoader\r\n```\r\n\r\n**Delegation model:** When asked to load a class, a child ClassLoader asks its parent first. If the parent can\u0027t find it, the child tries. This prevents your code from overriding JDK classes.\r\n\r\n### What is Heap Memory?\r\n\r\n**Definition:** The Heap is a shared memory area where ALL objects live. It\u0027s divided into generations for efficient garbage collection.\r\n\r\n```\r\nHeap (shared across all threads)\r\n├── Young Generation        ← new objects go here\r\n│   ├── Eden Space          ← brand new objects\r\n│   ├── Survivor 0 (S0)    ← survived 1+ minor GC\r\n│   └── Survivor 1 (S1)    ← alternate survivor space\r\n└── Old Generation (Tenured) ← long-lived objects (survived many GCs)\r\n\r\nMetaspace (off-heap, since Java 8) ← class metadata, method bytecode\r\n                                     (replaced PermGen from Java 7)\r\n```\r\n\r\n### What is Stack Memory?\r\n\r\n**Definition:** Each thread has its own Stack. Every method call creates a Stack Frame containing local variables, operand stack, and return address. When the method returns, the frame is popped.\r\n\r\n**StackOverflowError** = too many nested method calls (e.g., infinite recursion) exceeding the stack size.\r\n\r\n---\r\n\r\n## 2.5 Garbage Collection\r\n\r\n### What is Garbage Collection (GC)?\r\n\r\n**Definition:** GC is the JVM\u0027s automatic memory management process that identifies and reclaims memory occupied by objects that are no longer reachable (no references pointing to them).\r\n\r\n**In plain English:** When you create objects with `new`, they take memory. When no variable points to an object anymore, it\u0027s \"garbage.\" The GC finds and deletes these unreachable objects to free memory — you don\u0027t have to manually free memory like in C/C++.\r\n\r\n### How GC Works — Mark-and-Sweep\r\n\r\n```\r\n1. MARK    — Starting from GC Roots, traverse all reachable objects, mark as \"alive\"\r\n2. SWEEP   — Delete all unmarked (unreachable) objects\r\n3. COMPACT — (optional) Move surviving objects together to reduce fragmentation\r\n```\r\n\r\n### What are GC Roots?\r\n\r\n**Definition:** GC Roots are the starting points for GC\u0027s reachability analysis. Any object reachable from a GC Root is alive; everything else is garbage.\r\n\r\nGC Roots include:\r\n- Local variables on active thread stacks\r\n- Static fields\r\n- Active thread objects\r\n- JNI (native) references\r\n\r\n### What is Minor GC vs Major GC?\r\n\r\n| Type | Area | Speed | Frequency |\r\n|------|------|-------|-----------|\r\n| Minor GC | Young Generation (Eden + Survivors) | Fast (milliseconds) | Frequent |\r\n| Major/Full GC | Old Generation (entire heap) | Slow (stop-the-world pause) | Infrequent |\r\n\r\n### GC Algorithms\r\n\r\n**G1GC (Garbage-First) — Default since Java 9**\r\n- Divides heap into regions (not contiguous generations)\r\n- Collects regions with most garbage first → predictable pause times\r\n- Target pause: `-XX:MaxGCPauseMillis=200`\r\n- Good for: heaps 4GB+ with latency requirements\r\n\r\n**ZGC — Java 15+ (production-ready)**\r\n- Ultra-low latency: \u003c 1ms pauses regardless of heap size\r\n- Handles terabyte-sized heaps\r\n- Good for: latency-critical applications (trading, gaming)\r\n- Enable: `-XX:+UseZGC`\r\n\r\n### JVM Tuning Flags\r\n```bash\r\n-Xms512m          # Initial heap size\r\n-Xmx4g            # Maximum heap size\r\n-XX:+UseG1GC      # Use G1 (default)\r\n-XX:+UseZGC       # Use ZGC\r\n-XX:MaxMetaspaceSize=256m  # Limit metaspace\r\n-Xlog:gc*:file=gc.log     # GC logging\r\n```\r\n\r\n### Interview Q: \"How do you diagnose a memory leak?\"\r\n**Answer:** (1) Monitor heap usage over time via Actuator/Prometheus/Grafana. (2) If heap grows continuously without dropping after GC → likely a leak. (3) Take heap dump: `jmap -dump:format=b,file=heap.bin \u003cpid\u003e`. (4) Analyze with Eclipse MAT or VisualVM. (5) Look for: collections that keep growing, unclosed resources, static fields holding references, listeners never removed.\r\n\r\n---\r\n\r\n## 2.6 Multithreading \u0026 Concurrency\r\n\r\n### What is a Thread?\r\n\r\n**Definition:** A thread is the smallest unit of execution within a process. Multiple threads in the same process share memory (heap) but each has its own stack.\r\n\r\n### What is `synchronized`?\r\n\r\n**Definition:** The `synchronized` keyword creates a mutual exclusion lock (mutex) — only one thread can execute the synchronized block/method at a time on the same object.\r\n\r\n**In plain English:** It\u0027s like a bathroom door lock — only one person (thread) can be inside at a time. Others wait until it\u0027s free.\r\n\r\n```java\r\npublic class Counter {\r\n    private int count = 0;\r\n    public synchronized void increment() {\r\n        count++;  // only one thread can execute this at a time\r\n    }\r\n}\r\n```\r\n\r\n### What is `volatile`?\r\n\r\n**Definition:** The `volatile` keyword ensures that a variable\u0027s value is always read from main memory (not a thread\u0027s CPU cache), guaranteeing visibility across threads.\r\n\r\n**In plain English:** Without `volatile`, one thread might change a variable, but another thread keeps seeing the old (cached) value. `volatile` forces every read to check the \"shared truth.\"\r\n\r\n```java\r\nprivate volatile boolean running = true;\r\n\r\n// Thread 1\r\npublic void stop() { running = false; }\r\n\r\n// Thread 2\r\npublic void run() {\r\n    while (running) { doWork(); }  // without volatile, might loop forever!\r\n}\r\n```\r\n\r\n**IMPORTANT:** `volatile` guarantees visibility but NOT atomicity. `count++` on a volatile int is still NOT thread-safe (it\u0027s read-modify-write = 3 operations). Use `AtomicInteger` or `synchronized` for that.\r\n\r\n### What is ReentrantLock?\r\n\r\n**Definition:** ReentrantLock is a more flexible alternative to `synchronized` that offers try-lock, timeout, interruptibility, and multiple conditions.\r\n\r\n```java\r\nReentrantLock lock = new ReentrantLock();\r\nlock.lock();\r\ntry {\r\n    // critical section\r\n} finally {\r\n    lock.unlock();  // ALWAYS in finally block!\r\n}\r\n\r\n// Advantages over synchronized:\r\nlock.tryLock();                          // non-blocking attempt\r\nlock.tryLock(5, TimeUnit.SECONDS);       // timeout\r\nlock.lockInterruptibly();                // can be interrupted while waiting\r\n```\r\n\r\n### CompletableFuture — Advanced\r\n\r\n```java\r\n// Chain async operations\r\nCompletableFuture.supplyAsync(() -\u003e fetchUser(userId))      // run in ForkJoinPool\r\n    .thenApply(user -\u003e enrichUser(user))                     // transform\r\n    .thenCompose(user -\u003e fetchOrders(user.getId()))          // chain another async\r\n    .thenAccept(orders -\u003e sendNotification(orders))          // consume\r\n    .exceptionally(ex -\u003e { log.error(\"Failed\", ex); return null; });\r\n\r\n// Parallel: two independent fetches\r\nvar userFuture = CompletableFuture.supplyAsync(() -\u003e fetchUser(id));\r\nvar ordersFuture = CompletableFuture.supplyAsync(() -\u003e fetchOrders(id));\r\nvar profile = userFuture.thenCombine(ordersFuture,\r\n    (user, orders) -\u003e new UserProfile(user, orders));\r\n\r\n// Custom executor (for production — don\u0027t rely on default ForkJoinPool)\r\nExecutorService executor = Executors.newFixedThreadPool(10);\r\nCompletableFuture.supplyAsync(() -\u003e fetchData(), executor);\r\n```\r\n\r\n### Thread Pool Sizing Rules\r\n```\r\nCPU-bound tasks (computation):     threads = number of CPU cores\r\nI/O-bound tasks (DB, HTTP, file):  threads = cores × (1 + waitTime/computeTime)\r\n  Example: If 90% of time is waiting → threads = cores × 10\r\n\r\nSpring Boot Tomcat default: 200 threads\r\nWith virtual threads (Java 21): unlimited virtual threads on few carrier threads\r\n```\r\n\r\n---\r\n\r\n## 2.7 Java Memory Model (JMM)\r\n\r\n### What is the Java Memory Model?\r\n\r\n**Definition:** The JMM defines the rules for how threads interact through shared memory — specifically, when a write by one thread becomes visible to a read by another thread. It defines the \"happens-before\" relationship.\r\n\r\n### What is Happens-Before?\r\n\r\n**Definition:** If action A \"happens-before\" action B, then A\u0027s memory effects (writes) are guaranteed to be visible to B.\r\n\r\nKey rules:\r\n1. **Program order:** In a single thread, each statement happens-before the next\r\n2. **Monitor lock:** `unlock()` happens-before subsequent `lock()` on the same object\r\n3. **Volatile:** Write to volatile happens-before subsequent read of that volatile\r\n4. **Thread start:** `thread.start()` happens-before any action in the started thread\r\n5. **Thread join:** All actions in a thread happen-before `thread.join()` returns\r\n6. **Transitivity:** If A happens-before B, and B happens-before C, then A happens-before C\r\n\r\n---\r\n\r\n## 2.8 Generics Deep Dive\r\n\r\n### What are Generics?\r\n\r\n**Definition:** Generics allow you to write classes, interfaces, and methods that work with any type specified at compile time, providing type safety without casting.\r\n\r\n**In plain English:** Instead of writing separate code for `List of Strings` and `List of Integers`, you write `List\u003cT\u003e` once and specify T when you use it.\r\n\r\n### What is Type Erasure?\r\n\r\n**Definition:** The Java compiler replaces all type parameters with their bounds (or `Object`) during compilation. At runtime, `List\u003cString\u003e` and `List\u003cInteger\u003e` are both just `List`.\r\n\r\n**In plain English:** Generics exist only at compile time for type checking. At runtime, the type info is erased. That\u0027s why you CAN\u0027T do `new T()`, `T.class`, or `instanceof List\u003cString\u003e`.\r\n\r\n### What is PECS?\r\n\r\n**Definition:** PECS = Producer Extends, Consumer Super. A rule for choosing wildcards:\r\n- `? extends T` — when you READ FROM the collection (it produces values)\r\n- `? super T` — when you WRITE TO the collection (it consumes values)\r\n\r\n```java\r\n// Producer: read FROM it (extends)\r\npublic double sum(List\u003c? extends Number\u003e list) {\r\n    double total = 0;\r\n    for (Number n : list) total += n.doubleValue();  // safe to read as Number\r\n    return total;\r\n}\r\n\r\n// Consumer: write TO it (super)\r\npublic void addIntegers(List\u003c? super Integer\u003e list) {\r\n    list.add(1);  // safe to add Integer\r\n    list.add(2);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2.9 Functional Programming — Streams Advanced\r\n\r\n### Intermediate vs Terminal Operations\r\n\r\n**Definition:**\r\n- **Intermediate operations** (lazy — return a new Stream): `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, `peek()`, `limit()`, `skip()`\r\n- **Terminal operations** (trigger execution — return a result): `collect()`, `forEach()`, `reduce()`, `count()`, `findFirst()`, `findAny()`, `anyMatch()`, `allMatch()`, `noneMatch()`\r\n\r\n### Advanced Collectors\r\n\r\n```java\r\n// toList() (Java 16+) — unmodifiable\r\nList\u003cString\u003e names = users.stream().map(User::name).toList();\r\n\r\n// groupingBy — group by property\r\nMap\u003cString, List\u003cUser\u003e\u003e byCity = users.stream()\r\n    .collect(Collectors.groupingBy(User::city));\r\n\r\n// groupingBy + counting\r\nMap\u003cString, Long\u003e countByCity = users.stream()\r\n    .collect(Collectors.groupingBy(User::city, Collectors.counting()));\r\n\r\n// partitioningBy — split into true/false groups\r\nMap\u003cBoolean, List\u003cUser\u003e\u003e adults = users.stream()\r\n    .collect(Collectors.partitioningBy(u -\u003e u.age() \u003e= 18));\r\n\r\n// joining\r\nString csv = names.stream().collect(Collectors.joining(\", \"));\r\n\r\n// toMap (careful: duplicate keys throw exception)\r\nMap\u003cLong, User\u003e byId = users.stream()\r\n    .collect(Collectors.toMap(User::id, Function.identity(), (u1, u2) -\u003e u1));\r\n```\r\n\r\n### When NOT to Use Parallel Streams\r\n```java\r\n// DON\u0027T use parallel for: I/O ops, small lists, ordered operations, shared mutable state\r\n// DO use for: CPU-intensive, large datasets, independent elements\r\n```\r\n\r\n---\r\n\r\n## 2.10 ✅ What You\u0027ve Learnt After Module 2\r\n\r\n1. **HashMap internals** — buckets, hashing, collisions, treeification, equals/hashCode contract\r\n2. **ConcurrentHashMap** — fine-grained locking, when and why to use it\r\n3. **JVM architecture** — ClassLoader delegation, heap (young/old gen), stack, metaspace\r\n4. **Garbage Collection** — mark-and-sweep, G1GC, ZGC, diagnosing memory leaks\r\n5. **Multithreading** — synchronized, volatile, ReentrantLock, CompletableFuture, thread pool sizing\r\n6. **Java Memory Model** — happens-before rules, visibility guarantees\r\n7. **Generics** — type erasure, PECS rule, bounded wildcards\r\n8. **Streams** — advanced collectors, parallel streams, when NOT to use them\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-3\"\u003e\u003c/a\u003e\r\n# MODULE 3: Spring Boot Mastery (2.x → 3.x)\r\n\r\n\u003e **What this module is about:** Spring Boot is the backbone of Java backend development. This module covers everything from how Spring works under the hood to the Spring Boot 2→3 migration, security, JPA, testing, and performance.\r\n\r\n---\r\n\r\n## 3.0 Internal Revision — Spring Framework Basics\r\n\r\n### What is the Spring Framework?\r\n\r\n**Definition:** Spring is a Java application framework based on two core principles: **Inversion of Control (IoC)** and **Aspect-Oriented Programming (AOP)**. It manages object creation, wiring, and lifecycle so you focus on business logic.\r\n\r\n### What is Inversion of Control (IoC)?\r\n\r\n**Definition:** IoC means the framework controls object creation and dependency management instead of your code doing it manually with `new`. You declare what you need, Spring provides it.\r\n\r\n**In plain English:** Instead of YOU creating dependencies (`new OrderRepository()`) inside your service, Spring creates them and gives them to you. You just say \"I need an OrderRepository\" and Spring hands it over.\r\n\r\n### What is Dependency Injection (DI)?\r\n\r\n**Definition:** DI is the mechanism Spring uses to implement IoC. It \"injects\" (provides) the dependencies your class needs, either through the constructor, setter, or field.\r\n\r\n### What is a Bean?\r\n\r\n**Definition:** A Bean is any object managed by the Spring IoC container. You mark classes with annotations to tell Spring \"manage this for me.\"\r\n\r\n```java\r\n@Component     // generic Spring-managed bean\r\n@Service       // business logic layer (same as @Component, semantic difference)\r\n@Repository    // data access layer (adds exception translation)\r\n@Controller    // web layer (returns views)\r\n@RestController // = @Controller + @ResponseBody (returns JSON directly)\r\n```\r\n\r\n### Quick Spring Boot REST API Recap\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/users\")\r\npublic class UserController {\r\n\r\n    private final UserService userService;\r\n\r\n    public UserController(UserService userService) {  // constructor injection\r\n        this.userService = userService;\r\n    }\r\n\r\n    @GetMapping(\"/{id}\")\r\n    public User getUser(@PathVariable Long id) {\r\n        return userService.findById(id);\r\n    }\r\n\r\n    @PostMapping\r\n    @ResponseStatus(HttpStatus.CREATED)\r\n    public User createUser(@Valid @RequestBody CreateUserRequest request) {\r\n        return userService.create(request);\r\n    }\r\n}\r\n```\r\n\r\n### application.yml / application.properties\r\n\r\n```yaml\r\nserver:\r\n  port: 8080\r\nspring:\r\n  datasource:\r\n    url: jdbc:postgresql://localhost:5432/mydb\r\n    username: user\r\n    password: pass\r\n  jpa:\r\n    hibernate:\r\n      ddl-auto: validate  # never use \u0027create\u0027 or \u0027update\u0027 in production!\r\n```\r\n\r\n---\r\n\r\n## 3.1 Spring Boot 3.x Migration\r\n\r\n### What Changed — The Big Three\r\n\r\n**1. `javax.*` → `jakarta.*` Namespace**\r\n\r\n**Definition:** Jakarta EE is the renamed version of Java EE (after Oracle transferred it to Eclipse Foundation). The base package changed from `javax.*` to `jakarta.*`.\r\n\r\n```java\r\n// Spring Boot 2.x\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.Id;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.validation.Valid;\r\n\r\n// Spring Boot 3.x — change ALL javax to jakarta\r\nimport jakarta.persistence.Entity;\r\nimport jakarta.persistence.Id;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.validation.Valid;\r\n```\r\n\r\n**2. Java 17 Minimum Requirement** — Spring Boot 3 won\u0027t start on Java 8 or 11.\r\n\r\n**3. Spring Security API Overhaul:**\r\n\r\n```java\r\n// OLD (2.x) — REMOVED in 3.x\r\n@Configuration\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        http.csrf().disable()\r\n            .authorizeRequests()\r\n            .antMatchers(\"/api/public/**\").permitAll()\r\n            .anyRequest().authenticated();\r\n    }\r\n}\r\n\r\n// NEW (3.x) — SecurityFilterChain bean\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        return http\r\n            .csrf(csrf -\u003e csrf.disable())\r\n            .authorizeHttpRequests(auth -\u003e auth\r\n                .requestMatchers(\"/api/public/**\").permitAll()\r\n                .anyRequest().authenticated()\r\n            )\r\n            .build();\r\n    }\r\n}\r\n```\r\n\r\n### Full Migration Checklist\r\n\r\n| Change | Action |\r\n|--------|--------|\r\n| javax → jakarta | Find/replace all javax.* imports |\r\n| Java version | Minimum Java 17 |\r\n| Security | Remove `WebSecurityConfigurerAdapter`, use `SecurityFilterChain` bean |\r\n| Security matchers | `antMatchers()` → `requestMatchers()` |\r\n| Hibernate | 5.x → 6.x (SQL generation may change) |\r\n| Properties | `spring.redis.*` → `spring.data.redis.*` |\r\n| Actuator | `/actuator/env` no longer shows values by default |\r\n| Tracing | Spring Cloud Sleuth → Micrometer Observation API |\r\n\r\n---\r\n\r\n## 3.2 Spring IoC \u0026 Bean Lifecycle\r\n\r\n### What is the Bean Lifecycle?\r\n\r\n**Definition:** The sequence of steps Spring follows from detecting a Bean definition to creating the instance, injecting dependencies, initializing, and eventually destroying it.\r\n\r\n```\r\n1. BEAN DEFINITION LOADING\r\n   @ComponentScan finds @Component/@Service/@Repository classes\r\n   @Bean methods in @Configuration classes\r\n   Creates BeanDefinition objects (metadata only, no instances yet)\r\n\r\n2. INSTANTIATION — Call constructor (with DI if constructor injection)\r\n\r\n3. DEPENDENCY INJECTION — Inject @Autowired fields/setters\r\n\r\n4. AWARE INTERFACES (if implemented)\r\n   BeanNameAware.setBeanName()\r\n   ApplicationContextAware.setApplicationContext()\r\n\r\n5. BeanPostProcessor.postProcessBeforeInitialization()\r\n\r\n6. INITIALIZATION\r\n   @PostConstruct method\r\n   InitializingBean.afterPropertiesSet()\r\n   Custom init-method\r\n\r\n7. BeanPostProcessor.postProcessAfterInitialization()\r\n   ##### THIS IS WHERE AOP PROXIES ARE CREATED! #####\r\n\r\n8. Bean is READY — app uses it\r\n\r\n9. DESTRUCTION (on shutdown)\r\n   @PreDestroy method\r\n   DisposableBean.destroy()\r\n```\r\n\r\n### What are Bean Scopes?\r\n\r\n**Definition:** Scope determines how many instances of a bean Spring creates and how long they live.\r\n\r\n| Scope | Meaning | Instances |\r\n|-------|---------|-----------|\r\n| `singleton` (default) | One instance per Spring container | 1 total |\r\n| `prototype` | New instance every time it\u0027s requested | Many |\r\n| `request` | One per HTTP request (web apps only) | 1 per request |\r\n| `session` | One per HTTP session (web apps only) | 1 per session |\r\n\r\n```java\r\n@Component\r\n@Scope(\"prototype\")\r\npublic class PrototypeBean {}\r\n\r\n// GOTCHA: Injecting prototype into singleton → same prototype instance forever!\r\n// Fix: Use ObjectFactory\u003cT\u003e\r\n@Service\r\npublic class OrderService {\r\n    private final ObjectFactory\u003cPrototypeBean\u003e factory;\r\n    public void process() {\r\n        PrototypeBean bean = factory.getObject();  // NEW instance each time\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3.3 Dependency Injection — Constructor vs Field\r\n\r\n### Why Constructor Injection is PREFERRED\r\n\r\n```java\r\n// GOOD — Constructor Injection\r\n@Service\r\npublic class OrderService {\r\n    private final OrderRepository orderRepo;       // final = immutable\r\n    private final PaymentService paymentService;\r\n\r\n    public OrderService(OrderRepository orderRepo, PaymentService paymentService) {\r\n        this.orderRepo = orderRepo;\r\n        this.paymentService = paymentService;\r\n    }\r\n}\r\n```\r\n\r\n| Advantage | Why |\r\n|-----------|-----|\r\n| Immutable | Fields are `final` — can\u0027t be changed after construction |\r\n| Testable | Easy mocking: `new OrderService(mockRepo, mockPayment)` |\r\n| Fail-fast | Missing dependency fails at startup, not runtime |\r\n| No reflection | Field injection uses reflection to set private fields |\r\n\r\n```java\r\n// BAD — Field Injection\r\n@Service\r\npublic class OrderService {\r\n    @Autowired private OrderRepository orderRepo;    // not final, hidden dependency\r\n}\r\n```\r\n\r\n### @Qualifier and @Primary\r\n\r\n```java\r\n// When multiple beans implement the same interface:\r\n@Service(\"email\")\r\npublic class EmailSender implements NotificationSender { ... }\r\n\r\n@Service(\"sms\")\r\n@Primary  // used by default when no qualifier specified\r\npublic class SmsSender implements NotificationSender { ... }\r\n\r\n// Pick a specific one:\r\npublic OrderService(@Qualifier(\"email\") NotificationSender sender) { ... }\r\n```\r\n\r\n---\r\n\r\n## 3.4 Spring AOP — @Transactional Deep Dive\r\n\r\n### What is AOP (Aspect-Oriented Programming)?\r\n\r\n**Definition:** AOP allows you to add cross-cutting behavior (logging, security, transactions) to methods WITHOUT modifying the method itself. Spring uses proxy objects to intercept method calls and add behavior before/after.\r\n\r\n### How @Transactional Works Under the Hood\r\n\r\n```java\r\n@Service\r\npublic class OrderService {\r\n    @Transactional\r\n    public void createOrder(Order order) {\r\n        orderRepo.save(order);\r\n        inventoryService.reserve(order.getItems());\r\n        paymentService.charge(order);\r\n        // If ANY exception → ROLLBACK entire transaction\r\n    }\r\n}\r\n```\r\n\r\n**What Spring actually does:**\r\n```\r\nYour code calls: orderService.createOrder(order)\r\n  → Hits the PROXY (not the real object)\r\n  → Proxy: BEGIN TRANSACTION\r\n  → Proxy: Calls REAL createOrder()\r\n  → If success → COMMIT\r\n  → If RuntimeException → ROLLBACK\r\n```\r\n\r\n### The Self-Invocation Pitfall (TOP interview question)\r\n\r\n```java\r\n@Service\r\npublic class OrderService {\r\n    @Transactional\r\n    public void createOrder(Order order) { ... }\r\n\r\n    public void processOrders(List\u003cOrder\u003e orders) {\r\n        for (Order order : orders) {\r\n            this.createOrder(order);  // @Transactional IGNORED!\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Why?** `this.createOrder()` calls the real method directly, bypassing the proxy. The proxy only intercepts calls from OUTSIDE.\r\n\r\n**Fix 1:** Inject self: `@Lazy @Autowired private OrderService self;` → `self.createOrder(order);`\r\n\r\n**Fix 2:** Move `createOrder()` to a separate service.\r\n\r\n### Transaction Propagation\r\n\r\n| Propagation | Meaning |\r\n|-------------|---------|\r\n| `REQUIRED` (default) | Join existing TX, or create new |\r\n| `REQUIRES_NEW` | Always create new TX (suspend existing) |\r\n| `NESTED` | Create savepoint within existing TX |\r\n| `MANDATORY` | Must run within existing TX (throws if none) |\r\n| `SUPPORTS` | Join if TX exists, otherwise run without |\r\n| `NOT_SUPPORTED` | Suspend existing TX, run without |\r\n| `NEVER` | Throw if TX exists |\r\n\r\n---\r\n\r\n## 3.5 Spring MVC Request Lifecycle\r\n\r\n### What is DispatcherServlet?\r\n\r\n**Definition:** DispatcherServlet is Spring MVC\u0027s Front Controller — the single entry point that receives ALL HTTP requests and routes them to the appropriate controller.\r\n\r\n```\r\nClient HTTP Request\r\n  ↓\r\nDispatcherServlet (receives ALL requests)\r\n  ↓\r\nHandlerMapping (which controller method handles this URL?)\r\n  ↓\r\nHandlerInterceptor.preHandle() (if configured)\r\n  ↓\r\nController Method (@GetMapping/@PostMapping)\r\n  ↓\r\n@RequestBody → Jackson deserializes JSON → Java object\r\n  ↓\r\n@Valid → Bean Validation runs (field constraints)\r\n  ↓\r\nController returns object\r\n  ↓\r\n@ResponseBody → Jackson serializes Java → JSON\r\n  ↓\r\nHandlerInterceptor.postHandle()\r\n  ↓\r\nHTTP Response to client\r\n```\r\n\r\n### Global Exception Handling\r\n\r\n```java\r\n@RestControllerAdvice\r\npublic class GlobalExceptionHandler {\r\n\r\n    @ExceptionHandler(ResourceNotFoundException.class)\r\n    @ResponseStatus(HttpStatus.NOT_FOUND)\r\n    public ProblemDetail handleNotFound(ResourceNotFoundException ex) {\r\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\r\n            HttpStatus.NOT_FOUND, ex.getMessage());\r\n        problem.setTitle(\"Resource Not Found\");\r\n        problem.setProperty(\"timestamp\", Instant.now());\r\n        return problem;\r\n    }\r\n\r\n    @ExceptionHandler(MethodArgumentNotValidException.class)\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    public ProblemDetail handleValidation(MethodArgumentNotValidException ex) {\r\n        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST);\r\n        problem.setTitle(\"Validation Failed\");\r\n        var errors = ex.getBindingResult().getFieldErrors().stream()\r\n            .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage));\r\n        problem.setProperty(\"errors\", errors);\r\n        return problem;\r\n    }\r\n}\r\n```\r\n\r\n**What is ProblemDetail?** It follows RFC 7807 — the standard error format for REST APIs:\r\n```json\r\n{\r\n  \"type\": \"about:blank\",\r\n  \"title\": \"Resource Not Found\",\r\n  \"status\": 404,\r\n  \"detail\": \"User with id 42 not found\",\r\n  \"timestamp\": \"2026-02-13T10:30:00Z\"\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3.6 Spring Security — JWT Authentication\r\n\r\n### What is JWT?\r\n\r\n**Definition:** JSON Web Token (JWT) is a compact, self-contained token format for securely transmitting claims between parties. It contains a header (algorithm), payload (claims like userId, roles, expiry), and signature.\r\n\r\n**In plain English:** After login, the server gives the client a signed token. On every subsequent request, the client sends this token. The server verifies the signature (no DB lookup needed) and extracts user info from the token.\r\n\r\n### Complete JWT Flow\r\n\r\n```\r\n1. LOGIN: POST /api/auth/login { \"username\": \"alice\", \"password\": \"secret\" }\r\n   → Validate credentials → Generate JWT → Return { \"token\": \"eyJhbG...\" }\r\n\r\n2. EVERY SUBSEQUENT REQUEST: GET /api/orders\r\n   Header: Authorization: Bearer eyJhbG...\r\n   → JwtAuthFilter extracts token\r\n   → Verify signature + expiry\r\n   → Extract username from token\r\n   → Load UserDetails\r\n   → Set SecurityContext\r\n   → Request proceeds to controller\r\n```\r\n\r\n### JWT Security Config (Spring Boot 3)\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        return http\r\n            .csrf(csrf -\u003e csrf.disable())\r\n            .sessionManagement(session -\u003e\r\n                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n            .authorizeHttpRequests(auth -\u003e auth\r\n                .requestMatchers(\"/api/auth/**\").permitAll()\r\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\r\n                .anyRequest().authenticated()\r\n            )\r\n            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)\r\n            .build();\r\n    }\r\n\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3.7 Spring Data JPA — N+1 Problem\r\n\r\n### What is the N+1 Problem?\r\n\r\n**Definition:** The N+1 problem occurs when fetching a parent entity triggers N additional queries to load its related entities — one initial query + N subsequent queries for each parent.\r\n\r\n**In plain English:** You want all Authors with their Books. JPA runs 1 query for 100 authors, then 100 separate queries for each author\u0027s books = 101 queries. Should be 1.\r\n\r\n```java\r\n@Entity\r\npublic class Author {\r\n    @OneToMany(mappedBy = \"author\", fetch = FetchType.LAZY)\r\n    private List\u003cBook\u003e books;\r\n}\r\n\r\nList\u003cAuthor\u003e authors = authorRepo.findAll();  // 1 query\r\nfor (Author a : authors) {\r\n    a.getBooks().size();  // N queries! One per author!\r\n}\r\n// 100 authors → 101 queries total!\r\n```\r\n\r\n### Fixes\r\n\r\n```java\r\n// Fix 1: JOIN FETCH — load everything in 1 query\r\n@Query(\"SELECT a FROM Author a JOIN FETCH a.books\")\r\nList\u003cAuthor\u003e findAllWithBooks();\r\n\r\n// Fix 2: @EntityGraph\r\n@EntityGraph(attributePaths = {\"books\"})\r\nList\u003cAuthor\u003e findAll();\r\n\r\n// Fix 3: @BatchSize — fetch in batches of 20\r\n@OneToMany(mappedBy = \"author\")\r\n@BatchSize(size = 20)\r\nprivate List\u003cBook\u003e books;\r\n// 100 authors → 1 + 5 queries (20 at a time) instead of 101\r\n```\r\n\r\n---\r\n\r\n## 3.8 Testing in Spring Boot\r\n\r\n### What is @WebMvcTest?\r\n\r\n**Definition:** Loads ONLY the web layer (controller + filters). Service/repository beans are mocked. Fast.\r\n\r\n```java\r\n@WebMvcTest(UserController.class)\r\nclass UserControllerTest {\r\n    @Autowired MockMvc mockMvc;\r\n    @MockBean UserService userService;\r\n\r\n    @Test\r\n    void shouldReturnUser() throws Exception {\r\n        when(userService.findById(1L)).thenReturn(new User(1L, \"Alice\"));\r\n        mockMvc.perform(get(\"/api/users/1\"))\r\n            .andExpect(status().isOk())\r\n            .andExpect(jsonPath(\"$.name\").value(\"Alice\"));\r\n    }\r\n}\r\n```\r\n\r\n### What is @SpringBootTest with Testcontainers?\r\n\r\n**Definition:** Loads the FULL application context and connects to real infrastructure (DB, Redis, Kafka) running in Docker containers. Slow but high confidence.\r\n\r\n```java\r\n@SpringBootTest\r\n@Testcontainers\r\nclass OrderServiceIntegrationTest {\r\n    @Container\r\n    static PostgreSQLContainer\u003c?\u003e postgres = new PostgreSQLContainer\u003c\u003e(\"postgres:16\");\r\n\r\n    @DynamicPropertySource\r\n    static void configure(DynamicPropertyRegistry registry) {\r\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\r\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\r\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3.9 Spring Boot Actuator\r\n\r\n### What is Actuator?\r\n\r\n**Definition:** Actuator provides production-ready features — health checks, metrics, environment info — through HTTP endpoints.\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: health, metrics, info\r\n  endpoint:\r\n    health:\r\n      show-details: when-authorized\r\n      probes:\r\n        enabled: true  # Kubernetes liveness/readiness\r\n```\r\n\r\nKey endpoints: `/actuator/health`, `/actuator/metrics`, `/actuator/health/liveness`, `/actuator/health/readiness`\r\n\r\n---\r\n\r\n## 3.10 ✅ What You\u0027ve Learnt After Module 3\r\n\r\n1. **Spring Boot 2.x → 3.x migration** — javax→jakarta, Security API, Hibernate 6\r\n2. **IoC, DI, Bean lifecycle** — from definition to destruction\r\n3. **Constructor injection \u003e field injection** — with clear reasons\r\n4. **@Transactional internals** — proxy-based, self-invocation pitfall\r\n5. **Request lifecycle** — DispatcherServlet → Controller → Response\r\n6. **JWT Security** — complete flow and implementation\r\n7. **N+1 problem** — detect + fix (JOIN FETCH, EntityGraph, BatchSize)\r\n8. **Testing** — @WebMvcTest (unit) vs @SpringBootTest + Testcontainers (integration)\r\n9. **Actuator** — health checks, Kubernetes probes, metrics\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-4\"\u003e\u003c/a\u003e\r\n# MODULE 4: Microservices Architecture\r\n\r\n\u003e **What this module is about:** Most senior Java roles involve microservices. This module covers when to use them, how to design them, and the critical patterns (saga, circuit breaker, outbox, CQRS) that interviewers ask about.\r\n\r\n---\r\n\r\n## 4.0 Internal Revision — Monolithic Architecture\r\n\r\n### What is a Monolith?\r\n\r\n**Definition:** A monolithic application is a single deployable unit where all modules (users, orders, payments) share the same codebase, process, and database.\r\n\r\n```\r\n┌─────────────────────────────────────────┐\r\n│         Single Application (JAR/WAR)     │\r\n│  ┌──────────┐ ┌──────────┐ ┌──────────┐ │\r\n│  │  Users   │ │  Orders  │ │ Payments │ │\r\n│  └──────────┘ └──────────┘ └──────────┘ │\r\n│            Single Database               │\r\n└─────────────────────────────────────────┘\r\n```\r\n\r\n| Advantages | Disadvantages |\r\n|------------|---------------|\r\n| Simple to develop, test, deploy | Must scale EVERYTHING together |\r\n| Easy debugging (single process) | Change one line → redeploy all |\r\n| ACID transactions across modules | Teams coupled to one codebase |\r\n| No network latency between modules | One OOM error crashes everything |\r\n\r\n**Rule:** Start with a monolith. Extract microservices only when pain points emerge.\r\n\r\n---\r\n\r\n## 4.1 Microservices Fundamentals\r\n\r\n### What is a Microservice?\r\n\r\n**Definition:** A microservice is a small, independently deployable service that owns a single bounded context (business domain), has its own database, communicates via APIs or events, and can be developed/deployed by a small team.\r\n\r\n### What is a Bounded Context (DDD)?\r\n\r\n**Definition:** A bounded context is a logical boundary within which a particular domain model is defined. Each microservice owns one bounded context.\r\n\r\n**In plain English:** \"User\" means different things to different services. User Service cares about name/email/preferences. Payment Service only cares about userId + paymentMethod. Each service has its OWN model of \"User\" — they don\u0027t share a database.\r\n\r\n### What is an API Gateway?\r\n\r\n**Definition:** A single entry point for all client requests that routes them to the appropriate microservice. It handles cross-cutting concerns like authentication, rate limiting, and SSL termination.\r\n\r\n```\r\nClient → API Gateway → Order Service\r\n                     → User Service\r\n                     → Payment Service\r\n```\r\n\r\n---\r\n\r\n## 4.2 Circuit Breaker Pattern\r\n\r\n### What is a Circuit Breaker?\r\n\r\n**Definition:** A circuit breaker monitors calls to an external service. If failures exceed a threshold, it \"opens\" the circuit — immediately returning a fallback response without attempting the call. After a cooldown period, it tries again.\r\n\r\n**In plain English:** Like an electrical circuit breaker in your house. If too much current flows (too many failures), the breaker trips to prevent damage. After some time, you try resetting it.\r\n\r\n**States:** CLOSED (normal) → OPEN (all calls fail-fast) → HALF-OPEN (test a few calls)\r\n\r\n```java\r\n@Service\r\npublic class OrderService {\r\n    @CircuitBreaker(name = \"paymentService\", fallbackMethod = \"fallback\")\r\n    @Retry(name = \"paymentService\")\r\n    public PaymentResponse processPayment(PaymentRequest req) {\r\n        return paymentClient.charge(req);\r\n    }\r\n\r\n    private PaymentResponse fallback(PaymentRequest req, Exception ex) {\r\n        return new PaymentResponse(\"PENDING\", \"Service unavailable, will retry\");\r\n    }\r\n}\r\n```\r\n\r\n```yaml\r\nresilience4j:\r\n  circuitbreaker:\r\n    instances:\r\n      paymentService:\r\n        slidingWindowSize: 10\r\n        failureRateThreshold: 50      # open if 50% of last 10 calls fail\r\n        waitDurationInOpenState: 10s   # wait before trying again\r\n  retry:\r\n    instances:\r\n      paymentService:\r\n        maxAttempts: 3\r\n        waitDuration: 1s\r\n        exponentialBackoffMultiplier: 2  # 1s, 2s, 4s\r\n```\r\n\r\n---\r\n\r\n## 4.3 Saga Pattern\r\n\r\n### What is a Saga?\r\n\r\n**Definition:** A saga is a sequence of local transactions across multiple services. If one step fails, compensating transactions undo the previous steps. It replaces distributed ACID transactions (which don\u0027t work across microservices).\r\n\r\n**In plain English:** You can\u0027t do a database transaction across 3 different databases. Instead, each service does its own transaction, and if something fails midway, you \"undo\" the earlier steps (refund the payment, unreserve the inventory).\r\n\r\n**Two approaches:**\r\n\r\n**Choreography (event-based):** Each service publishes events; other services listen and react.\r\n```\r\nOrder Service → publishes \"OrderCreated\"\r\n  → Payment Service listens → charges → publishes \"PaymentCompleted\"\r\n     → Inventory Service listens → reserves → publishes \"InventoryReserved\"\r\n\r\nIf Payment fails → publishes \"PaymentFailed\"\r\n  → Order Service listens → cancels order (compensating transaction)\r\n```\r\n\r\n**Orchestration (central coordinator):** One component directs the workflow.\r\n```\r\nSaga Orchestrator:\r\n  Step 1: Call Payment Service → charge\r\n  Step 2: Call Inventory → reserve\r\n  Step 3: Call Notification → notify\r\n  If Step 2 fails → Call Payment → refund (compensation)\r\n```\r\n\r\n---\r\n\r\n## 4.4 Outbox Pattern\r\n\r\n### What is the Outbox Pattern?\r\n\r\n**Definition:** Instead of saving to DB AND publishing to Kafka in two separate operations (which can fail independently), you save the data AND the event in the SAME database transaction. A separate process later reads the outbox table and publishes to Kafka.\r\n\r\n**Why it matters:** Without this, you get data inconsistency: DB save succeeds → Kafka publish fails → event is lost.\r\n\r\n```\r\n┌────────────────────────────┐\r\n│     SINGLE Transaction      │\r\n│  INSERT INTO orders (...)   │\r\n│  INSERT INTO outbox (...)   │\r\n│  COMMIT                     │\r\n└────────────────────────────┘\r\n        ↓ (CDC or polling)\r\n┌────────────────────────────┐\r\n│  Read outbox → Kafka topic  │\r\n│  Mark entry as published    │\r\n└────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## 4.5 CQRS \u0026 Event Sourcing\r\n\r\n### What is CQRS?\r\n\r\n**Definition:** Command Query Responsibility Segregation — separate the WRITE model (commands) from the READ model (queries). Use different data stores optimized for each.\r\n\r\n**In plain English:** Writes go to a normalized database (accurate, consistent). Reads come from a denormalized read store (fast, pre-joined). An event keeps them in sync.\r\n\r\n### What is Event Sourcing?\r\n\r\n**Definition:** Instead of storing the current state, you store every event (state change) that happened. The current state is rebuilt by replaying all events.\r\n\r\n**In plain English:** Instead of storing \"account balance = $500\", you store: \"deposited $100\", \"deposited $200\", \"withdrew $50\", \"deposited $250\". Replay all = $500.\r\n\r\n---\r\n\r\n## 4.6 Distributed Tracing\r\n\r\n### What is Distributed Tracing?\r\n\r\n**Definition:** Tracking a single request as it flows through multiple microservices by propagating a unique trace-id across all service calls. Each service adds its \"span\" to the trace.\r\n\r\n**Tool:** OpenTelemetry (standard) + Jaeger or Zipkin (visualization)\r\n\r\n---\r\n\r\n## 4.7 ✅ What You\u0027ve Learnt After Module 4\r\n\r\n1. **Monolith vs Microservices** — trade-offs, when to migrate\r\n2. **Bounded contexts (DDD)** — each service owns its domain model\r\n3. **Circuit breaker** — prevent cascading failures with Resilience4j\r\n4. **Saga pattern** — distributed transactions (choreography vs orchestration)\r\n5. **Outbox pattern** — reliable event publishing\r\n6. **CQRS + Event Sourcing** — separate read/write, event-driven state\r\n7. **Distributed tracing** — request tracking across services\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-5\"\u003e\u003c/a\u003e\r\n# MODULE 5: Database Mastery (Oracle SQL + PostgreSQL)\r\n\r\n\u003e **What this module is about:** As a backend developer, your database knowledge is tested in EVERY interview. This module covers Oracle SQL deep dives (your current expertise), PostgreSQL (the industry standard you need to pick up), indexing internals, query optimization, transactions, Redis caching, and pgvector for AI. After this module, no database question can stump you.\r\n\r\n---\r\n\r\n## 5.0 Internal Revision — SQL \u0026 RDBMS Foundations\r\n\r\n### What is a Relational Database?\r\n\r\n**Definition:** A database that stores data in structured tables (rows and columns) with defined relationships between tables using primary keys (PK) and foreign keys (FK).\r\n\r\n**In plain English:** Think of it as a collection of Excel spreadsheets where each sheet is a table, each row is one record, and sheets can reference each other. \"The orders table points to the users table via user_id.\"\r\n\r\n### What is a Primary Key?\r\n\r\n**Definition:** A column (or set of columns) that uniquely identifies every row in a table. No two rows can have the same PK value, and it cannot be NULL.\r\n\r\n**In plain English:** It\u0027s the ID card for each row — no duplicates, no blanks.\r\n\r\n### What is a Foreign Key?\r\n\r\n**Definition:** A column in one table that references the primary key of another table, creating a relationship between them.\r\n\r\n**In plain English:** It\u0027s a \"pointer\" from one table to another. `orders.user_id` points to `users.id` — that\u0027s a foreign key.\r\n\r\n### What is a JOIN?\r\n\r\n**Definition:** A SQL operation that combines rows from two or more tables based on a related column (usually a foreign key relationship).\r\n\r\n**Types:**\r\n```sql\r\n-- INNER JOIN  → only rows that match in BOTH tables\r\nSELECT u.name, o.total FROM users u\r\nINNER JOIN orders o ON u.id = o.user_id;\r\n\r\n-- LEFT JOIN   → ALL rows from left table + matching from right (NULL if no match)\r\nSELECT u.name, o.total FROM users u\r\nLEFT JOIN orders o ON u.id = o.user_id;\r\n-- Shows all users, even those with zero orders (o.total = NULL)\r\n\r\n-- RIGHT JOIN  → ALL rows from right table + matching from left\r\n-- FULL OUTER JOIN → ALL rows from BOTH tables\r\n-- CROSS JOIN  → every row from A combined with every row from B (cartesian product)\r\n```\r\n\r\n### What is Normalization?\r\n\r\n**Definition:** The process of organizing tables to reduce data redundancy and avoid anomalies (insert/update/delete inconsistencies).\r\n\r\n**Forms:**\r\n```\r\n1NF — each column holds one value (no lists/arrays in a cell)\r\n       BAD:  | name  | phones          |\r\n             | Alice | 111-222, 333-444|\r\n       GOOD: | name  | phone   |\r\n             | Alice | 111-222 |\r\n             | Alice | 333-444 |\r\n\r\n2NF — 1NF + every non-key column depends on the ENTIRE primary key\r\n       (eliminate partial dependencies in composite keys)\r\n\r\n3NF — 2NF + no transitive dependencies\r\n       (non-key columns must not depend on other non-key columns)\r\n       BAD:  employee table has: department_id, department_name\r\n       GOOD: move department_name to a departments table\r\n```\r\n\r\n**In plain English:** 1NF = no lists. 2NF = every column relates to the full key. 3NF = columns only describe the key, nothing else. Design in 3NF, denormalize when performance demands it.\r\n\r\n### What is an Index?\r\n\r\n**Definition:** A data structure (typically a B-Tree) that the database creates alongside the table to speed up lookups. Like the index at the back of a textbook—instead of reading every page, you jump to the right one.\r\n\r\n**In plain English:** Without an index, the database reads every row from top to bottom (full table scan). With an index, it jumps straight to the matching rows. Reads become fast, but writes become slightly slower (index must also be updated).\r\n\r\n### What is a Transaction?\r\n\r\n**Definition:** A sequence of SQL operations that either ALL succeed together or ALL fail together. Described by ACID properties.\r\n\r\n### What is ACID?\r\n\r\n```\r\nA — Atomicity:    All or nothing. Either all SQL statements in the transaction\r\n                  succeed, or none of them are applied.\r\n\r\nC — Consistency:  The database moves from one valid state to another.\r\n                  All constraints (PK, FK, CHECK, UNIQUE) remain satisfied.\r\n\r\nI — Isolation:    Concurrent transactions don\u0027t interfere with each other.\r\n                  Each transaction sees a consistent snapshot of data.\r\n\r\nD — Durability:   Once committed, the data is permanently saved (even if\r\n                  the server crashes right after).\r\n```\r\n\r\n### What is GROUP BY / HAVING?\r\n\r\n```sql\r\n-- GROUP BY: Aggregate rows with the same values\r\n-- HAVING: Filter AFTER aggregation (WHERE filters BEFORE aggregation)\r\n\r\nSELECT department, COUNT(*) emp_count, AVG(salary) avg_salary\r\nFROM employees\r\nWHERE status = \u0027ACTIVE\u0027            -- filters individual rows FIRST\r\nGROUP BY department                -- then groups\r\nHAVING AVG(salary) \u003e 50000         -- then filters groups\r\nORDER BY avg_salary DESC;\r\n```\r\n\r\n### What is a Subquery?\r\n\r\n**Definition:** A query nested inside another query. The inner query runs first, its result is used by the outer query.\r\n\r\n```sql\r\n-- Subquery in WHERE\r\nSELECT name FROM employees\r\nWHERE salary \u003e (SELECT AVG(salary) FROM employees);\r\n\r\n-- Subquery in FROM (derived table)\r\nSELECT dept, avg_sal FROM (\r\n    SELECT department AS dept, AVG(salary) AS avg_sal\r\n    FROM employees GROUP BY department\r\n) sub WHERE avg_sal \u003e 60000;\r\n\r\n-- Correlated subquery (references outer query — runs once per row)\r\nSELECT e.name FROM employees e\r\nWHERE e.salary \u003e (SELECT AVG(salary) FROM employees WHERE department = e.department);\r\n```\r\n\r\n---\r\n\r\n## 5.1 Window / Analytical Functions\r\n\r\n### What are Window Functions?\r\n\r\n**Definition:** Functions that perform calculations across a set of rows (a \"window\") related to the current row, WITHOUT collapsing the rows into groups (unlike GROUP BY). Each row keeps its identity.\r\n\r\n**In plain English:** GROUP BY gives you one result row per group. Window functions give you the calculation BESIDE each original row. You get the detail AND the aggregate together.\r\n\r\n### ROW_NUMBER, RANK, DENSE_RANK\r\n\r\n```sql\r\n-- ROW_NUMBER: assigns 1, 2, 3... unique sequential numbers per partition\r\nSELECT name, department, salary,\r\n    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rn\r\nFROM employees;\r\n-- Each department: top earner = 1, next = 2, etc. NO ties.\r\n\r\n-- RANK: same value gets same rank, BUT skips next numbers\r\n-- Salaries: 100, 100, 90 → RANK: 1, 1, 3 (skips 2)\r\n\r\n-- DENSE_RANK: same value gets same rank, NO skip\r\n-- Salaries: 100, 100, 90 → DENSE_RANK: 1, 1, 2\r\n```\r\n\r\n### Top N Per Group (THE most commonly asked SQL question)\r\n\r\n```sql\r\n-- Get top 3 highest-paid employees in each department\r\nSELECT * FROM (\r\n    SELECT name, department, salary,\r\n        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rn\r\n    FROM employees\r\n) ranked WHERE rn \u003c= 3;\r\n```\r\n\r\n### LAG / LEAD\r\n\r\n**Definition:** Access data from a previous row (`LAG`) or next row (`LEAD`) in the result set, relative to the current row.\r\n\r\n```sql\r\n-- Compare each employee\u0027s salary with the previous hire\u0027s salary\r\nSELECT name, salary, hire_date,\r\n    LAG(salary, 1) OVER (ORDER BY hire_date) as prev_salary,\r\n    salary - LAG(salary, 1) OVER (ORDER BY hire_date) as salary_change\r\nFROM employees;\r\n```\r\n\r\n### Running Total / Cumulative Sum\r\n\r\n```sql\r\nSELECT order_date, amount,\r\n    SUM(amount) OVER (ORDER BY order_date\r\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as running_total\r\nFROM orders;\r\n-- Each row shows: this order\u0027s amount + sum of all previous orders\r\n```\r\n\r\n---\r\n\r\n## 5.2 Oracle SQL Advanced\r\n\r\n### What is a Hierarchical Query?\r\n\r\n**Definition:** An Oracle-specific SQL construct that traverses parent-child relationships (tree structures) in a single query, using `START WITH` and `CONNECT BY`.\r\n\r\n**In plain English:** If employees have managers, and managers have managers, this query walks the tree: CEO → VP → Director → Manager → Developer.\r\n\r\n```sql\r\nSELECT LPAD(\u0027 \u0027, (LEVEL-1)*2) || name AS org_chart, employee_id, manager_id, LEVEL\r\nFROM employees\r\nSTART WITH manager_id IS NULL         -- root: the CEO (no manager)\r\nCONNECT BY PRIOR employee_id = manager_id;  -- child\u0027s manager_id = parent\u0027s employee_id\r\n```\r\n\r\n### Oracle-Specific Functions\r\n\r\n```sql\r\n-- NVL: replace NULL with a default (Oracle only)\r\nSELECT NVL(phone, \u0027N/A\u0027) FROM users;\r\n-- Standard equivalent: COALESCE(phone, \u0027N/A\u0027)\r\n\r\n-- DECODE: inline IF-THEN-ELSE (Oracle only)\r\nSELECT DECODE(status, \u0027A\u0027, \u0027Active\u0027, \u0027I\u0027, \u0027Inactive\u0027, \u0027Unknown\u0027) FROM orders;\r\n-- Standard equivalent: CASE WHEN status = \u0027A\u0027 THEN \u0027Active\u0027 ... END\r\n\r\n-- ROWNUM: numbering rows (applied BEFORE ORDER BY — tricky!)\r\n-- WRONG: SELECT * FROM employees WHERE ROWNUM \u003c= 10 ORDER BY salary DESC;\r\n-- RIGHT:\r\nSELECT * FROM (SELECT * FROM employees ORDER BY salary DESC) WHERE ROWNUM \u003c= 10;\r\n\r\n-- FETCH FIRST (Oracle 12c+ / ANSI standard — preferred)\r\nSELECT * FROM employees ORDER BY salary DESC FETCH FIRST 10 ROWS ONLY;\r\n```\r\n\r\n---\r\n\r\n## 5.3 PostgreSQL — What You Need to Learn\r\n\r\n### PostgreSQL vs Oracle — Key Differences\r\n\r\n```\r\n| Concept          | Oracle                     | PostgreSQL                         |\r\n|-----------------|----------------------------|------------------------------------|\r\n| Auto-increment  | SEQUENCE + trigger         | SERIAL or GENERATED ALWAYS AS IDENTITY |\r\n| Null check      | NVL(x, \u0027default\u0027)          | COALESCE(x, \u0027default\u0027)             |\r\n| Current time    | SYSDATE                    | NOW() or CURRENT_TIMESTAMP         |\r\n| Limit rows      | ROWNUM / FETCH FIRST       | LIMIT n OFFSET m                   |\r\n| Boolean         | NUMBER(1) or CHAR(1)       | BOOLEAN (true/false natively)      |\r\n| Empty string    | \u0027\u0027 is treated as NULL       | \u0027\u0027 is NOT NULL (they are different) |\r\n| FROM DUAL       | SELECT 1 FROM DUAL          | SELECT 1 (no DUAL needed)          |\r\n| JSON support    | Limited                    | JSONB (powerful, indexable)         |\r\n| Sequences       | seq_name.NEXTVAL           | nextval(\u0027seq_name\u0027)                |\r\n| Outer join      | (+) syntax available       | Standard LEFT/RIGHT JOIN only      |\r\n| String concat   | \u0027a\u0027 || \u0027b\u0027 or CONCAT       | \u0027a\u0027 || \u0027b\u0027 or CONCAT              |\r\n```\r\n\r\n### What is JSONB?\r\n\r\n**Definition:** A PostgreSQL data type that stores JSON data in a binary format. Unlike plain JSON, JSONB is decomposed into a binary structure that supports indexing, fast queries, and containment checks.\r\n\r\n**In plain English:** You can store a whole JSON object in a single column and still query individual fields inside it efficiently. It\u0027s like having a NoSQL document store inside your relational database.\r\n\r\n```sql\r\nCREATE TABLE events (\r\n    id SERIAL PRIMARY KEY,\r\n    data JSONB NOT NULL\r\n);\r\n\r\nINSERT INTO events (data) VALUES\r\n(\u0027{\"type\": \"click\", \"page\": \"/home\", \"user\": {\"id\": 1, \"name\": \"Alice\"}}\u0027);\r\n\r\n-- Query JSON fields\r\nSELECT data-\u003e\u003e\u0027type\u0027 as event_type FROM events;         -- \"click\" (as text)\r\nSELECT data-\u003e\u0027user\u0027-\u003e\u003e\u0027name\u0027 FROM events;               -- \"Alice\"\r\nSELECT * FROM events WHERE data-\u003e\u003e\u0027type\u0027 = \u0027click\u0027;\r\nSELECT * FROM events WHERE data @\u003e \u0027{\"type\": \"click\"}\u0027; -- containment operator (fast with GIN index)\r\n\r\n-- Index JSONB\r\nCREATE INDEX idx_events_gin ON events USING GIN (data);              -- index everything\r\nCREATE INDEX idx_events_type ON events ((data-\u003e\u003e\u0027type\u0027));            -- index one field\r\n```\r\n\r\n### PostgreSQL Arrays\r\n\r\n```sql\r\n-- PostgreSQL supports array columns (Oracle does not)\r\nCREATE TABLE tags (id SERIAL, labels TEXT[]);\r\nINSERT INTO tags (labels) VALUES (ARRAY[\u0027java\u0027, \u0027spring\u0027, \u0027kafka\u0027]);\r\n\r\nSELECT * FROM tags WHERE \u0027java\u0027 = ANY(labels);        -- contains \"java\"?\r\nSELECT * FROM tags WHERE labels @\u003e ARRAY[\u0027java\u0027];     -- same, containment\r\n```\r\n\r\n---\r\n\r\n## 5.4 Indexing Deep Dive\r\n\r\n### What is a B-Tree Index?\r\n\r\n**Definition:** The default index type in most databases. A balanced tree structure where data is sorted and each node points to child nodes, allowing the database to find any value in O(log n) time.\r\n\r\n**In plain English:** Imagine a phone book sorted alphabetically. To find \"Smith\", you don\u0027t start at page 1—you open roughly to \"S\", then narrow down. That\u0027s what a B-Tree does for the database.\r\n\r\n```sql\r\n-- Create a B-Tree index (default)\r\nCREATE INDEX idx_users_email ON users(email);\r\n-- Now: SELECT * FROM users WHERE email = \u0027alice@example.com\u0027 → index scan (fast)\r\n-- Without: full table scan (slow for millions of rows)\r\n```\r\n\r\n### What is a Composite Index?\r\n\r\n**Definition:** An index on two or more columns together. The column ORDER matters because of the **leftmost prefix rule**.\r\n\r\n```sql\r\nCREATE INDEX idx_orders_user_date ON orders(user_id, order_date);\r\n\r\n-- ✅ Uses index: WHERE user_id = 1\r\n-- ✅ Uses index: WHERE user_id = 1 AND order_date \u003e \u00272025-01-01\u0027\r\n-- ❌ Does NOT use index: WHERE order_date \u003e \u00272025-01-01\u0027  (missing leftmost column!)\r\n```\r\n\r\n**In plain English:** Think of a phone book sorted by (last_name, first_name). You can look up \"Smith\" easily. You can look up \"Smith, John\" too. But you CANNOT efficiently look up everyone named \"John\" across all last names.\r\n\r\n### What is a Partial Index?\r\n\r\n**Definition:** An index that only covers rows matching a WHERE condition. Smaller index = faster searches + less storage.\r\n\r\n```sql\r\nCREATE INDEX idx_orders_active ON orders(user_id) WHERE status = \u0027ACTIVE\u0027;\r\n-- Only indexes active orders. If 90% of orders are completed, this index is 10x smaller.\r\n```\r\n\r\n### What is a Covering Index?\r\n\r\n**Definition:** An index that contains ALL columns needed by a query, so the database never needs to look at the actual table data (index-only scan).\r\n\r\n```sql\r\nCREATE INDEX idx_users_email_name ON users(email) INCLUDE (name);\r\n-- SELECT name FROM users WHERE email = \u0027x\u0027 → reads ONLY the index, never touches the table\r\n```\r\n\r\n### EXPLAIN ANALYZE — Reading Query Plans\r\n\r\n**Definition:** A command that shows HOW the database will execute your query (which indexes it uses, row estimates, actual time).\r\n\r\n```sql\r\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = \u0027alice@example.com\u0027;\r\n\r\n-- What to look for:\r\n-- Seq Scan         → BAD: full table scan. Add an index!\r\n-- Index Scan       → GOOD: uses index to find rows\r\n-- Bitmap Index Scan→ OK: uses index, then fetches pages in bulk\r\n-- Index Only Scan  → BEST: all data is in the index, zero table access\r\n-- Nested Loop      → OK for small datasets, bad for large\r\n-- Hash Join        → GOOD for large joins\r\n-- Sort             → check if it can use an index to avoid sorting\r\n```\r\n\r\n---\r\n\r\n## 5.5 Transactions \u0026 Locking\r\n\r\n### What are Transaction Isolation Levels?\r\n\r\n**Definition:** Rules that define how much one transaction can \"see\" changes made by other concurrent transactions. Higher isolation = more correct but slower.\r\n\r\n```\r\nLevel              | Dirty Read | Non-Repeatable Read | Phantom Read | Speed\r\n-------------------|------------|--------------------|--------------|---------\r\nRead Uncommitted   | YES        | YES                | YES          | Fastest\r\nRead Committed     | NO         | YES                | YES          | Fast (PG default)\r\nRepeatable Read    | NO         | NO                 | YES*         | Medium\r\nSerializable       | NO         | NO                 | NO           | Slowest\r\n```\r\n\r\n**Definitions of anomalies:**\r\n- **Dirty Read:** You see another transaction\u0027s uncommitted changes (they might rollback!)\r\n- **Non-Repeatable Read:** You read the same row twice and get different values (someone updated it between your reads)\r\n- **Phantom Read:** You run the same query twice and get different ROW COUNTS (someone inserted/deleted rows between your queries)\r\n\r\n**In plain English:** Read Committed (default) means \"I only see stuff that\u0027s been committed.\" Serializable means \"the database acts as if only one transaction runs at a time\" — safest but slowest.\r\n\r\n### What is Optimistic Locking?\r\n\r\n**Definition:** Instead of locking rows, you add a `version` column. When updating, you check if the version is the same as when you read it. If someone else changed it, the version won\u0027t match and the update fails.\r\n\r\n```java\r\n@Entity\r\npublic class Order {\r\n    @Id private Long id;\r\n    @Version private Integer version;   // Hibernate checks this automatically\r\n    // If two users edit the same order simultaneously,\r\n    // the second save attempt throws OptimisticLockException\r\n}\r\n```\r\n\r\n**When to use:** Web apps with low collision probability. Most CRUD operations.\r\n\r\n### What is Pessimistic Locking?\r\n\r\n**Definition:** Lock the row in the database so no one else can read or modify it until your transaction commits.\r\n\r\n```sql\r\nSELECT * FROM orders WHERE id = 1 FOR UPDATE;\r\n-- This row is now locked. Other transactions trying to SELECT FOR UPDATE will WAIT.\r\n```\r\n\r\n**When to use:** High-collision scenarios like inventory decrement (two people buying the last item).\r\n\r\n---\r\n\r\n## 5.6 Database Scaling Concepts\r\n\r\n### What is Replication?\r\n\r\n**Definition:** Keeping copies of your database on multiple servers. One is the PRIMARY (handles writes), others are REPLICAS (handle reads).\r\n\r\n**In plain English:** One master database gets all the writes. Multiple copies serve read traffic. If you have 80% reads, you can spread that 80% across 5 replicas.\r\n\r\n### What is Sharding?\r\n\r\n**Definition:** Splitting your data across multiple database servers by a shard key. Each server holds a portion of the data.\r\n\r\n**In plain English:** Users A-M go to Database 1, users N-Z go to Database 2. Each database is smaller and handles less load.\r\n\r\n**Trade-off:** Cross-shard queries (joining data from both shards) are very expensive or impossible.\r\n\r\n### What is Partitioning?\r\n\r\n**Definition:** Splitting a large table into smaller physical segments within the SAME database. The database handles routing transparently.\r\n\r\n```sql\r\n-- Range partition: split orders by year\r\nCREATE TABLE orders (\r\n    id SERIAL, order_date DATE, amount DECIMAL\r\n) PARTITION BY RANGE (order_date);\r\n\r\nCREATE TABLE orders_2024 PARTITION OF orders FOR VALUES FROM (\u00272024-01-01\u0027) TO (\u00272025-01-01\u0027);\r\nCREATE TABLE orders_2025 PARTITION OF orders FOR VALUES FROM (\u00272025-01-01\u0027) TO (\u00272026-01-01\u0027);\r\n-- Queries with WHERE order_date = \u00272025-06-15\u0027 only scan orders_2025 partition\r\n```\r\n\r\n### What is Connection Pooling?\r\n\r\n**Definition:** Reusing a pool of pre-established database connections instead of opening a new connection for each request. Opening a connection is expensive (TCP handshake + authentication).\r\n\r\n**Tool:** HikariCP (default in Spring Boot — the fastest Java connection pool).\r\n\r\n```yaml\r\nspring:\r\n  datasource:\r\n    hikari:\r\n      maximum-pool-size: 20       # max concurrent connections\r\n      minimum-idle: 5             # keep at least 5 ready\r\n      connection-timeout: 30000   # wait max 30s for a connection\r\n      idle-timeout: 600000        # close idle connections after 10 min\r\n```\r\n\r\n---\r\n\r\n## 5.7 Redis\r\n\r\n### What is Redis?\r\n\r\n**Definition:** An in-memory, key-value data store used primarily as a cache, message broker, or session store. Data lives in RAM (not disk), so reads/writes are sub-millisecond.\r\n\r\n**In plain English:** It\u0027s a super-fast dictionary in memory. Store frequently accessed data here so you don\u0027t hit the database every time.\r\n\r\n### Cache-Aside Pattern\r\n\r\n**Definition:** The application checks the cache first. If the data is there (cache hit), return it. If not (cache miss), query the database, store the result in the cache, then return it.\r\n\r\n```java\r\npublic User getUser(Long id) {\r\n    // 1. Check cache\r\n    String cached = redis.get(\"user:\" + id);\r\n    if (cached != null) return deserialize(cached);\r\n\r\n    // 2. Cache miss → query DB\r\n    User user = userRepo.findById(id).orElseThrow();\r\n\r\n    // 3. Store in cache with TTL (Time-To-Live)\r\n    redis.setex(\"user:\" + id, 3600, serialize(user));  // expires in 1 hour\r\n    return user;\r\n}\r\n```\r\n\r\n### Spring Cache Abstraction\r\n\r\n```java\r\n@Cacheable(value = \"users\", key = \"#id\")       // reads from cache; if miss, calls method \u0026 caches result\r\npublic User getUser(Long id) {\r\n    return userRepo.findById(id).orElseThrow();\r\n}\r\n\r\n@CacheEvict(value = \"users\", key = \"#id\")      // removes from cache when data changes\r\npublic void updateUser(Long id, UpdateRequest req) { ... }\r\n\r\n@CachePut(value = \"users\", key = \"#result.id\") // always calls method AND updates cache\r\npublic User createUser(CreateRequest req) { ... }\r\n```\r\n\r\n### Redis Data Structures (beyond simple key-value)\r\n\r\n```\r\nString:  SET user:1:name \"Alice\"  / GET user:1:name      → simple values\r\nHash:    HSET user:1 name \"Alice\" age 30                  → like a mini-object\r\nList:    LPUSH queue:emails \"msg1\" / RPOP queue:emails    → message queue\r\nSet:     SADD tags:post:1 \"java\" \"spring\"                 → unique values\r\nSorted Set: ZADD leaderboard 100 \"alice\" 95 \"bob\"        → ranked data\r\n```\r\n\r\n### What is Cache Invalidation?\r\n\r\n**Definition:** The process of removing or updating stale data from the cache when the source data changes. This is one of the two hardest problems in computer science.\r\n\r\n**Strategies:**\r\n- **TTL (Time-To-Live):** Cache auto-expires after N seconds. Simple. Slightly stale data during TTL window.\r\n- **Event-based:** When data changes, publish an event that triggers cache eviction. Near-real-time.\r\n- **Write-through:** Every write goes to both cache and DB simultaneously. Always consistent but slower writes.\r\n\r\n---\r\n\r\n## 5.8 pgvector — Vector Search in PostgreSQL\r\n\r\n### What is pgvector?\r\n\r\n**Definition:** A PostgreSQL extension that adds a `vector` data type and similarity search operators. It lets you store embeddings (numerical representations of text/images) and find similar items using cosine similarity or Euclidean distance.\r\n\r\n**In plain English:** When you convert text to numbers using an AI model (embeddings), pgvector lets you store those numbers in PostgreSQL and search for \"what\u0027s most similar?\" — like a search engine inside your database.\r\n\r\n```sql\r\n-- 1. Enable the extension\r\nCREATE EXTENSION vector;\r\n\r\n-- 2. Create table with vector column (1536 = OpenAI embedding dimensions)\r\nCREATE TABLE documents (\r\n    id SERIAL PRIMARY KEY,\r\n    content TEXT,\r\n    embedding vector(1536)\r\n);\r\n\r\n-- 3. Create index for fast similarity search\r\nCREATE INDEX ON documents USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);\r\n\r\n-- 4. Find 5 most similar documents to a query vector\r\nSELECT content, 1 - (embedding \u003c=\u003e \u0027[0.1, 0.2, ...]\u0027::vector) as similarity\r\nFROM documents\r\nORDER BY embedding \u003c=\u003e \u0027[0.1, 0.2, ...]\u0027::vector\r\nLIMIT 5;\r\n-- \u003c=\u003e is cosine distance. 1 - distance = similarity.\r\n```\r\n\r\n---\r\n\r\n## 5.9 ✅ What You\u0027ve Learnt After Module 5\r\n\r\n1. **SQL foundations** — JOINs, GROUP BY, subqueries, normalization\r\n2. **Window functions** — ROW_NUMBER, RANK, LAG/LEAD, running totals, top-N-per-group\r\n3. **Oracle advanced** — hierarchical queries, NVL, DECODE, ROWNUM\r\n4. **PostgreSQL** — JSONB, arrays, differences from Oracle, LIMIT/OFFSET\r\n5. **Indexing** — B-Tree, composite (leftmost prefix rule), partial, covering\r\n6. **EXPLAIN ANALYZE** — reading query plans, identifying full table scans\r\n7. **Transactions** — ACID, isolation levels, dirty/non-repeatable/phantom reads\r\n8. **Locking** — optimistic (version column) vs pessimistic (FOR UPDATE)\r\n9. **Scaling** — replication, sharding, partitioning, connection pooling (HikariCP)\r\n10. **Redis** — cache-aside pattern, Spring Cache, data structures, invalidation strategies\r\n11. **pgvector** — vector embeddings in PostgreSQL for AI similarity search\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-6\"\u003e\u003c/a\u003e\r\n# MODULE 6: Apache Kafka \u0026 Event-Driven Architecture\r\n\r\n\u003e **What this module is about:** Kafka is the backbone of modern event-driven systems. Almost every senior backend interview includes questions about message brokers, event ordering, and exactly-once delivery. This module covers Kafka architecture, Spring Kafka integration, delivery guarantees, and production tuning.\r\n\r\n---\r\n\r\n## 6.0 Internal Revision — Messaging Fundamentals\r\n\r\n### What is a Message Queue?\r\n\r\n**Definition:** A middleware system that allows one application to send messages to another asynchronously. The sender (producer) puts a message on the queue; the receiver (consumer) picks it up later.\r\n\r\n**In plain English:** Instead of App A calling App B directly (synchronous), App A drops a note in a mailbox (queue). App B picks it up when ready. This way, App A doesn\u0027t wait, and App B can process at its own pace.\r\n\r\n### What is Synchronous vs Asynchronous Communication?\r\n\r\n**Synchronous:** Caller sends a request and WAITS for a response. Like a phone call — both sides must be active.\r\n\r\n**Asynchronous:** Caller sends a message and moves on. Like texting — you send it and don\u0027t wait.\r\n\r\n```\r\nSynchronous:   User Service ---HTTP call---\u003e Order Service (waits for response)\r\nAsynchronous:  User Service ---Kafka event---\u003e Order Service (processes whenever ready)\r\n```\r\n\r\n### Point-to-Point vs Publish-Subscribe\r\n\r\n```\r\nPoint-to-Point (Queue):\r\n  Producer → Queue → ONE Consumer picks up the message\r\n  Example: SQS, RabbitMQ (default mode)\r\n  Use when: each task should be processed exactly once by one worker\r\n\r\nPub/Sub (Topic):\r\n  Producer → Topic → ALL Subscribers receive a copy\r\n  Example: SNS, Redis Pub/Sub\r\n  Use when: multiple services need the same notification\r\n\r\nKafka: Combines both! Using Consumer Groups:\r\n  - Different consumer groups get their OWN copy (pub/sub behavior)\r\n  - Within a consumer group, each message goes to ONE consumer (queue behavior)\r\n```\r\n\r\n### What is Eventual Consistency?\r\n\r\n**Definition:** A model where after a write, not all readers will immediately see the new value, but eventually (after some time) all readers will see it.\r\n\r\n**In plain English:** When you post on social media, your friends might not see it instantly. Some see it in 1 second, others in 5 seconds. But eventually everyone sees it. That\u0027s eventual consistency — traded for speed and availability.\r\n\r\n---\r\n\r\n## 6.1 Kafka Architecture\r\n\r\n### What is Apache Kafka?\r\n\r\n**Definition:** A distributed event streaming platform that stores ordered sequences of events (messages) in topics. It is designed for high throughput, fault tolerance, and durability.\r\n\r\n**In plain English:** Kafka is a giant, durable, super-fast log. Producers append messages to the log. Consumers read from the log at their own pace. Messages are NOT deleted after consumption—they persist for a configurable time (default 7 days). Multiple consumers can read the same messages independently.\r\n\r\n### Core Components\r\n\r\n```\r\nBROKER:    A Kafka server. A cluster has multiple brokers for fault tolerance.\r\nTOPIC:     A named stream of messages (like a DB table name). e.g., \"orders\", \"payments\"\r\nPARTITION: A topic is split into partitions for parallelism. Each partition is an ordered,\r\n           immutable log of messages.\r\nOFFSET:    A unique sequential ID for each message within a partition. Consumers track\r\n           their position by offset.\r\nPRODUCER:  Application that writes messages to a topic.\r\nCONSUMER:  Application that reads messages from a topic.\r\nCONSUMER GROUP: A set of consumers that share the work of reading partitions.\r\n```\r\n\r\n### Visual Architecture\r\n\r\n```\r\n                      Kafka Cluster (3 Brokers)\r\n┌─────────────────────────────────────────────────────────┐\r\n│  Broker 1            Broker 2            Broker 3       │\r\n│  ┌────────────┐     ┌────────────┐     ┌────────────┐  │\r\n│  │ orders-P0  │     │ orders-P1  │     │ orders-P2  │  │\r\n│  │ (leader)   │     │ (leader)   │     │ (leader)   │  │\r\n│  │ orders-P1  │     │ orders-P2  │     │ orders-P0  │  │\r\n│  │ (replica)  │     │ (replica)  │     │ (replica)  │  │\r\n│  └────────────┘     └────────────┘     └────────────┘  │\r\n└─────────────────────────────────────────────────────────┘\r\n\r\nProducer sends: key=\"user-123\", value=OrderCreatedEvent\r\n  → key hash % 3 = partition number → goes to that partition\r\n\r\nConsumer Group \"order-service\" (3 instances):\r\n  Instance A → reads Partition 0\r\n  Instance B → reads Partition 1\r\n  Instance C → reads Partition 2\r\n\r\nConsumer Group \"analytics-service\" (1 instance):\r\n  Instance X → reads ALL 3 partitions (gets every message)\r\n```\r\n\r\n### Ordering Guarantees\r\n\r\n**CRITICAL RULE:** Messages within a SINGLE partition are ordered. Across partitions, there is NO ordering guarantee.\r\n\r\n**In plain English:** If User-123 places 3 orders, and all 3 go to Partition 0 (because the key is \"user-123\"), they\u0027ll be processed in order. But User-123\u0027s orders and User-456\u0027s orders (on different partitions) have no ordering relative to each other.\r\n\r\n**Partition key choice matters:** Use `userId` as the key → all events for the same user go to the same partition → guaranteed per-user ordering.\r\n\r\n---\r\n\r\n## 6.2 Spring Kafka — Producer\r\n\r\n```java\r\n// Configuration\r\n@Configuration\r\npublic class KafkaConfig {\r\n    @Bean\r\n    public ProducerFactory\u003cString, Object\u003e producerFactory() {\r\n        Map\u003cString, Object\u003e config = Map.of(\r\n            ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\",\r\n            ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class,\r\n            ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class,\r\n            ProducerConfig.ACKS_CONFIG, \"all\",        // wait for ALL replicas\r\n            ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true  // prevent duplicates on retry\r\n        );\r\n        return new DefaultKafkaProducerFactory\u003c\u003e(config);\r\n    }\r\n\r\n    @Bean\r\n    public KafkaTemplate\u003cString, Object\u003e kafkaTemplate() {\r\n        return new KafkaTemplate\u003c\u003e(producerFactory());\r\n    }\r\n}\r\n\r\n// Producer Service\r\n@Service\r\npublic class OrderEventPublisher {\r\n    private final KafkaTemplate\u003cString, Object\u003e kafkaTemplate;\r\n\r\n    public void publishOrderCreated(Order order) {\r\n        var event = new OrderCreatedEvent(order.getId(), order.getUserId(), order.getTotal());\r\n        kafkaTemplate.send(\"orders\", order.getUserId().toString(), event);\r\n        //                  topic    key (determines partition)      value\r\n    }\r\n}\r\n```\r\n\r\n### What does `acks=all` mean?\r\n\r\n**Definition:** The producer waits until the message is written to the leader AND all in-sync replicas before considering the send successful. This gives the strongest durability guarantee.\r\n\r\n```\r\nacks=0    → fire and forget (fastest, can lose data)\r\nacks=1    → leader acknowledged (good balance)\r\nacks=all  → all replicas acknowledged (safest, slowest)\r\n```\r\n\r\n---\r\n\r\n## 6.3 Spring Kafka — Consumer\r\n\r\n```java\r\n@Service\r\npublic class OrderEventConsumer {\r\n\r\n    @KafkaListener(topics = \"orders\", groupId = \"notification-service\")\r\n    public void handleOrderEvent(OrderCreatedEvent event, Acknowledgment ack) {\r\n        try {\r\n            // Process the event\r\n            notificationService.sendOrderConfirmation(event);\r\n\r\n            // Manually commit offset — tells Kafka \"I\u0027ve processed this message\"\r\n            ack.acknowledge();\r\n        } catch (Exception e) {\r\n            // Don\u0027t acknowledge → Kafka will redeliver this message\r\n            log.error(\"Failed to process order event: {}\", event.getOrderId(), e);\r\n            throw e;  // let error handler deal with it\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### What is an Offset?\r\n\r\n**Definition:** A sequential number assigned to each message within a partition. The consumer tracks which offset it has processed last. On restart, it continues from that offset.\r\n\r\n**In plain English:** It\u0027s a bookmark. \"I\u0027ve read up to message #42. When I restart, start from #43.\"\r\n\r\n### What is Auto-Commit vs Manual Commit?\r\n\r\n```yaml\r\nspring:\r\n  kafka:\r\n    consumer:\r\n      enable-auto-commit: false    # RECOMMENDED for reliability\r\n      # Auto-commit: Kafka auto-advances the offset on a timer (default 5s)\r\n      #   RISK: if your app crashes AFTER auto-commit but BEFORE processing → message lost!\r\n      # Manual commit: you call ack.acknowledge() AFTER processing\r\n      #   SAFE: if app crashes before ack, message will be redelivered\r\n```\r\n\r\n---\r\n\r\n## 6.4 Delivery Guarantees\r\n\r\n### At-Most-Once, At-Least-Once, Exactly-Once\r\n\r\n```\r\nAt-Most-Once:   Message may be lost, but never processed twice.\r\n                How: auto-commit offset before processing.\r\n                Use: logging, metrics (loss is acceptable)\r\n\r\nAt-Least-Once:  Message is never lost, but may be processed twice.\r\n                How: commit offset AFTER processing. If crash before commit → redelivery.\r\n                Use: most business events (handle duplicates with idempotency)\r\n\r\nExactly-Once:   Message is processed exactly once. NO loss, NO duplicates.\r\n                How: Kafka transactions (producer) + idempotent consumer\r\n                Use: financial transactions, inventory updates\r\n```\r\n\r\n### Making Your Consumer Idempotent\r\n\r\n**Definition:** An idempotent operation produces the same result no matter how many times it\u0027s executed.\r\n\r\n```java\r\n@KafkaListener(topics = \"payments\")\r\npublic void handlePayment(PaymentEvent event, Acknowledgment ack) {\r\n    // Check if we\u0027ve already processed this event\r\n    if (processedEventRepo.existsById(event.getEventId())) {\r\n        ack.acknowledge();  // skip duplicate\r\n        return;\r\n    }\r\n\r\n    paymentService.process(event);                       // process\r\n    processedEventRepo.save(event.getEventId());         // record\r\n    ack.acknowledge();                                   // commit\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6.5 Dead Letter Topic (DLT)\r\n\r\n### What is a Dead Letter Topic?\r\n\r\n**Definition:** A separate Kafka topic where messages that fail processing after all retry attempts are sent, instead of being lost or blocking the consumer.\r\n\r\n**In plain English:** If a message fails 3 times, instead of retrying forever or losing it, move it to a \"failed messages\" topic. A human or automated process can investigate and reprocess later.\r\n\r\n```java\r\n@Configuration\r\npublic class KafkaConfig {\r\n    @Bean\r\n    public DefaultErrorHandler errorHandler(KafkaTemplate\u003cString, Object\u003e template) {\r\n        var recoverer = new DeadLetterPublishingRecoverer(template);\r\n        return new DefaultErrorHandler(recoverer, new FixedBackOff(1000L, 3));\r\n        //   retry 3 times, 1 second apart → then send to DLT\r\n    }\r\n}\r\n// Failed messages go to topic: \"orders.DLT\"\r\n```\r\n\r\n---\r\n\r\n## 6.6 Kafka Performance Tuning\r\n\r\n```yaml\r\nspring:\r\n  kafka:\r\n    producer:\r\n      batch-size: 16384         # batch messages before sending (16 KB)\r\n      linger-ms: 5              # wait up to 5ms to fill a batch\r\n      compression-type: snappy  # compress batches (reduces network I/O)\r\n      buffer-memory: 33554432   # 32 MB producer buffer\r\n\r\n    consumer:\r\n      max-poll-records: 500     # fetch up to 500 messages per poll\r\n      fetch-min-bytes: 1        # minimum data to fetch\r\n      fetch-max-wait-ms: 500    # wait up to 500ms to accumulate data\r\n```\r\n\r\n### Key Tuning Rules\r\n- **More partitions = more parallelism** (but more overhead). Rule of thumb: start with 3-6 partitions per topic.\r\n- **Number of consumers in a group ≤ number of partitions.** Extra consumers sit idle.\r\n- **Batch size + linger.ms:** Trade latency for throughput. Higher = more throughput, higher latency.\r\n\r\n---\r\n\r\n## 6.7 ✅ What You\u0027ve Learnt After Module 6\r\n\r\n1. **Messaging fundamentals** — sync vs async, point-to-point vs pub/sub, eventual consistency\r\n2. **Kafka architecture** — brokers, topics, partitions, offsets, consumer groups\r\n3. **Ordering guarantees** — per-partition only; choose partition key wisely\r\n4. **Spring Kafka** — producer (KafkaTemplate), consumer (@KafkaListener), manual offset commit\r\n5. **Delivery guarantees** — at-most-once, at-least-once, exactly-once\r\n6. **Idempotent consumers** — deduplication to handle redelivery safely\r\n7. **Dead Letter Topic** — handling poison messages without blocking the consumer\r\n8. **Performance tuning** — batch size, compression, linger.ms, partition count\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-7\"\u003e\u003c/a\u003e\r\n# MODULE 7: API Design \u0026 Communication\r\n\r\n\u003e **What this module is about:** Every backend developer builds APIs. Interviewers test whether you understand REST deeply (not just GET/POST), pagination strategies, versioning, idempotency, and when to use alternatives like gRPC, GraphQL, or WebSockets. This module makes you an API design expert.\r\n\r\n---\r\n\r\n## 7.0 Internal Revision — HTTP Fundamentals\r\n\r\n### What is HTTP?\r\n\r\n**Definition:** HyperText Transfer Protocol — the application-layer protocol that powers the web. It\u0027s a request-response protocol: the client sends a request, the server sends a response.\r\n\r\n### What is a REST API?\r\n\r\n**Definition:** Representational State Transfer — an architectural style for building APIs. REST APIs use HTTP methods on resources (URLs) and return data (usually JSON).\r\n\r\n**The 6 REST Constraints:**\r\n1. **Client-Server** — client and server are separate, evolve independently\r\n2. **Stateless** — each request contains ALL information needed; server stores no session state\r\n3. **Cacheable** — responses can indicate if they\u0027re cacheable\r\n4. **Uniform Interface** — consistent URL naming, standard HTTP methods\r\n5. **Layered System** — client doesn\u0027t know if it talks to the server directly or through a load balancer\r\n6. **Code on Demand** (optional) — server can send executable code (JavaScript)\r\n\r\n### HTTP Methods (Verbs)\r\n\r\n```\r\nGET     → Read a resource. Safe (no side effects). Idempotent.\r\nPOST    → Create a new resource. NOT idempotent (calling twice creates two resources).\r\nPUT     → Replace a resource entirely. Idempotent.\r\nPATCH   → Partially update a resource. Not always idempotent.\r\nDELETE  → Remove a resource. Idempotent.\r\n```\r\n\r\n### HTTP Status Codes\r\n\r\n```\r\n2xx — Success\r\n  200 OK              → request succeeded\r\n  201 Created         → resource created (POST)\r\n  204 No Content      → success, no body (DELETE)\r\n\r\n3xx — Redirection\r\n  301 Moved Permanently → URL changed forever\r\n  304 Not Modified      → cached version is still valid\r\n\r\n4xx — Client Error\r\n  400 Bad Request     → invalid input / validation failed\r\n  401 Unauthorized    → not authenticated (who are you?)\r\n  403 Forbidden       → authenticated but not authorized (you can\u0027t do this)\r\n  404 Not Found       → resource doesn\u0027t exist\r\n  409 Conflict        → request conflicts with current state (duplicate, version mismatch)\r\n  429 Too Many Requests → rate limit exceeded\r\n\r\n5xx — Server Error\r\n  500 Internal Server Error → unexpected server failure\r\n  502 Bad Gateway     → upstream service returned invalid response\r\n  503 Service Unavailable → server is overloaded or in maintenance\r\n  504 Gateway Timeout → upstream service took too long\r\n```\r\n\r\n### What is JSON?\r\n\r\n**Definition:** JavaScript Object Notation — a lightweight text format for data exchange. The standard format for REST API request/response bodies.\r\n\r\n```json\r\n{\r\n  \"id\": 1,\r\n  \"name\": \"Alice\",\r\n  \"email\": \"alice@example.com\",\r\n  \"roles\": [\"ADMIN\", \"USER\"],\r\n  \"address\": {\r\n    \"city\": \"Bangalore\",\r\n    \"pin\": \"560001\"\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7.1 REST API Best Practices\r\n\r\n### Resource Naming\r\n\r\n```\r\n✅ GOOD (nouns, plural, hierarchical):\r\n  GET    /api/users              → list all users\r\n  GET    /api/users/123          → get user 123\r\n  POST   /api/users              → create a user\r\n  PUT    /api/users/123          → replace user 123\r\n  PATCH  /api/users/123          → update user 123 partially\r\n  DELETE /api/users/123          → delete user 123\r\n  GET    /api/users/123/orders   → list user 123\u0027s orders\r\n\r\n❌ BAD (verbs in URLs):\r\n  GET /api/getUsers\r\n  POST /api/createUser\r\n  POST /api/deleteUser/123\r\n```\r\n\r\n### Spring Boot Implementation\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/v1/users\")\r\npublic class UserController {\r\n\r\n    @GetMapping\r\n    public Page\u003cUserResponse\u003e listUsers(\r\n            @RequestParam(defaultValue = \"0\") int page,\r\n            @RequestParam(defaultValue = \"20\") int size) {\r\n        return userService.findAll(PageRequest.of(page, size));\r\n    }\r\n\r\n    @GetMapping(\"/{id}\")\r\n    public UserResponse getUser(@PathVariable Long id) {\r\n        return userService.findById(id);\r\n    }\r\n\r\n    @PostMapping\r\n    @ResponseStatus(HttpStatus.CREATED)\r\n    public UserResponse createUser(@Valid @RequestBody CreateUserRequest request) {\r\n        return userService.create(request);\r\n    }\r\n\r\n    @PatchMapping(\"/{id}\")\r\n    public UserResponse updateUser(@PathVariable Long id,\r\n                                    @Valid @RequestBody UpdateUserRequest request) {\r\n        return userService.update(id, request);\r\n    }\r\n\r\n    @DeleteMapping(\"/{id}\")\r\n    @ResponseStatus(HttpStatus.NO_CONTENT)\r\n    public void deleteUser(@PathVariable Long id) {\r\n        userService.delete(id);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7.2 Pagination\r\n\r\n### Offset-Based Pagination\r\n\r\n**Definition:** Skip N records, return the next M. Simple but breaks down at large offsets.\r\n\r\n```sql\r\nSELECT * FROM orders ORDER BY created_at DESC LIMIT 20 OFFSET 1000;\r\n-- DB must scan and discard 1000 rows before returning 20. Slow at page 50+.\r\n```\r\n\r\n```json\r\n{\r\n  \"data\": [...],\r\n  \"page\": 5,\r\n  \"size\": 20,\r\n  \"totalElements\": 1543,\r\n  \"totalPages\": 78\r\n}\r\n```\r\n\r\n### Cursor-Based Pagination (Preferred for large datasets)\r\n\r\n**Definition:** Instead of page numbers, use the last item\u0027s ID (or timestamp) as a cursor to fetch the next batch. The database uses an index to jump directly.\r\n\r\n```sql\r\n-- First page\r\nSELECT * FROM orders ORDER BY id DESC LIMIT 20;\r\n\r\n-- Next page (cursor = id of last item from previous page)\r\nSELECT * FROM orders WHERE id \u003c 980 ORDER BY id DESC LIMIT 20;\r\n-- Uses index! Always fast regardless of how deep you go.\r\n```\r\n\r\n```json\r\n{\r\n  \"data\": [...],\r\n  \"nextCursor\": \"eyJpZCI6OTgwfQ==\",\r\n  \"hasMore\": true\r\n}\r\n```\r\n\r\n**When to use which:**\r\n- Offset: Simple admin panels, small datasets, need \"page 5 of 78\"\r\n- Cursor: Infinite scroll, feeds, large datasets, API consumers\r\n\r\n---\r\n\r\n## 7.3 API Versioning\r\n\r\n### Strategies\r\n\r\n```\r\nURL versioning (most common, clearest):\r\n  /api/v1/users\r\n  /api/v2/users\r\n\r\nHeader versioning:\r\n  GET /api/users\r\n  Accept: application/vnd.myapp.v2+json\r\n\r\nQuery param:\r\n  /api/users?version=2\r\n```\r\n\r\n**Best practice:** Use URL versioning (`/v1/`, `/v2/`). It\u0027s the most explicit, easiest to document, and cache-friendly.\r\n\r\n---\r\n\r\n## 7.4 Error Handling — RFC 7807\r\n\r\n### What is RFC 7807 (Problem Details)?\r\n\r\n**Definition:** A standard format for returning error details in HTTP APIs. Instead of every API inventing its own error format, RFC 7807 defines a consistent structure.\r\n\r\n```json\r\n{\r\n  \"type\": \"https://api.myapp.com/errors/validation\",\r\n  \"title\": \"Validation Failed\",\r\n  \"status\": 400,\r\n  \"detail\": \"Email format is invalid\",\r\n  \"instance\": \"/api/users\",\r\n  \"errors\": {\r\n    \"email\": \"must be a valid email address\",\r\n    \"name\": \"must not be blank\"\r\n  }\r\n}\r\n```\r\n\r\nSpring Boot 3.x has built-in support via `ProblemDetail`:\r\n\r\n```java\r\n@RestControllerAdvice\r\npublic class GlobalErrorHandler {\r\n\r\n    @ExceptionHandler(ResourceNotFoundException.class)\r\n    public ProblemDetail handleNotFound(ResourceNotFoundException ex) {\r\n        ProblemDetail problem = ProblemDetail.forStatusAndDetail(\r\n            HttpStatus.NOT_FOUND, ex.getMessage());\r\n        problem.setTitle(\"Resource Not Found\");\r\n        problem.setProperty(\"timestamp\", Instant.now());\r\n        return problem;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7.5 Idempotency\r\n\r\n### What is Idempotency?\r\n\r\n**Definition:** An operation is idempotent if performing it multiple times produces the same result as performing it once. `GET`, `PUT`, `DELETE` are naturally idempotent. `POST` is NOT.\r\n\r\n**In plain English:** If you press the \"Pay\" button 3 times due to network issues, the customer should only be charged once. That requires making your payment API idempotent.\r\n\r\n### Idempotency Key Pattern\r\n\r\n```java\r\n@PostMapping(\"/api/payments\")\r\npublic PaymentResponse createPayment(\r\n        @RequestHeader(\"Idempotency-Key\") String idempotencyKey,\r\n        @RequestBody PaymentRequest request) {\r\n\r\n    // Check if we\u0027ve already processed this key\r\n    Optional\u003cPayment\u003e existing = paymentRepo.findByIdempotencyKey(idempotencyKey);\r\n    if (existing.isPresent()) {\r\n        return toResponse(existing.get());  // return cached result, don\u0027t charge again\r\n    }\r\n\r\n    // Process payment\r\n    Payment payment = paymentService.charge(request);\r\n    payment.setIdempotencyKey(idempotencyKey);\r\n    paymentRepo.save(payment);\r\n    return toResponse(payment);\r\n}\r\n```\r\n\r\n**How the client uses it:** Generate a UUID once: `Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000`. If the request times out, retry with the SAME key. The server detects it\u0027s a duplicate and returns the original response.\r\n\r\n---\r\n\r\n## 7.6 gRPC\r\n\r\n### What is gRPC?\r\n\r\n**Definition:** A high-performance, open-source Remote Procedure Call (RPC) framework created by Google. It uses Protocol Buffers (Protobuf) for serialization (binary, not JSON) and HTTP/2 for transport (multiplexing, streaming).\r\n\r\n**In plain English:** REST uses JSON over HTTP/1.1. gRPC uses binary data over HTTP/2. It\u0027s faster, smaller, and supports streaming. But it\u0027s harder to debug and not browser-friendly.\r\n\r\n### When to use gRPC vs REST?\r\n\r\n```\r\nREST:  external APIs (browser/mobile clients), public APIs, simple CRUD\r\ngRPC:  internal service-to-service calls, high-performance, low-latency,\r\n       real-time streaming, polyglot services (auto-generates client code)\r\n```\r\n\r\n### Protobuf Definition\r\n\r\n```protobuf\r\n// user.proto\r\nsyntax = \"proto3\";\r\n\r\nservice UserService {\r\n  rpc GetUser (UserRequest) returns (UserResponse);\r\n  rpc ListUsers (Empty) returns (stream UserResponse);  // server-side streaming\r\n}\r\n\r\nmessage UserRequest {\r\n  int64 id = 1;\r\n}\r\n\r\nmessage UserResponse {\r\n  int64 id = 1;\r\n  string name = 2;\r\n  string email = 3;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7.7 GraphQL\r\n\r\n### What is GraphQL?\r\n\r\n**Definition:** A query language for APIs (created by Facebook). The client specifies exactly which fields it wants, and the server returns only those fields. Solves the problems of overfetching and underfetching.\r\n\r\n**In plain English:** With REST, `GET /api/users/123` returns all 20 fields of a user, even if the mobile app only needs name and avatar. With GraphQL, the client says \"give me just name and avatar\" and that\u0027s all they get.\r\n\r\n```graphql\r\n# Client query\r\n{\r\n  user(id: 123) {\r\n    name\r\n    avatar\r\n    orders(last: 5) {\r\n      id\r\n      total\r\n    }\r\n  }\r\n}\r\n\r\n# Server returns exactly:\r\n{\r\n  \"data\": {\r\n    \"user\": {\r\n      \"name\": \"Alice\",\r\n      \"avatar\": \"https://...\",\r\n      \"orders\": [\r\n        { \"id\": 1, \"total\": 99.99 },\r\n        { \"id\": 2, \"total\": 49.50 }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Trade-off:** More flexible for clients, but harder to cache, harder to rate-limit, and can lead to N+1 queries on the backend.\r\n\r\n---\r\n\r\n## 7.8 WebSockets\r\n\r\n### What is a WebSocket?\r\n\r\n**Definition:** A protocol that provides full-duplex (two-way) communication between client and server over a single, long-lived TCP connection. Unlike HTTP (request → response), both sides can send data at any time.\r\n\r\n**In plain English:** HTTP is like sending letters — you send one, wait for a reply. WebSocket is like a phone call — once connected, both sides talk freely in real time.\r\n\r\n```\r\nUse cases:\r\n  Chat applications (WhatsApp, Slack)\r\n  Live dashboards (stock prices, sports scores)\r\n  Notifications (real-time push)\r\n  Online gaming\r\n  Collaborative editing (Google Docs)\r\n```\r\n\r\n```java\r\n// Spring Boot WebSocket\r\n@Configuration\r\n@EnableWebSocketMessageBroker\r\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\r\n    @Override\r\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\r\n        registry.addEndpoint(\"/ws\").withSockJS();\r\n    }\r\n    @Override\r\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\r\n        registry.enableSimpleBroker(\"/topic\");\r\n        registry.setApplicationDestinationPrefixes(\"/app\");\r\n    }\r\n}\r\n\r\n@Controller\r\npublic class ChatController {\r\n    @MessageMapping(\"/chat.send\")          // client sends to /app/chat.send\r\n    @SendTo(\"/topic/messages\")              // broadcast to all subscribers\r\n    public ChatMessage send(ChatMessage message) {\r\n        return message;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7.9 ✅ What You\u0027ve Learnt After Module 7\r\n\r\n1. **HTTP fundamentals** — methods, status codes, REST constraints\r\n2. **REST best practices** — resource naming, proper HTTP method usage\r\n3. **Pagination** — offset (simple) vs cursor (scalable), when to use which\r\n4. **API versioning** — URL versioning preferred\r\n5. **Error handling** — RFC 7807 ProblemDetail standard, Spring Boot implementation\r\n6. **Idempotency** — idempotency key pattern for safe retries (critical for payments)\r\n7. **gRPC** — binary + HTTP/2 for fast internal communication, Protobuf\r\n8. **GraphQL** — client-driven queries, overfetching/underfetching solved\r\n9. **WebSockets** — real-time bidirectional communication\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-8\"\u003e\u003c/a\u003e\r\n# MODULE 8: Docker, Kubernetes \u0026 Cloud (AWS)\r\n\r\n\u003e **What this module is about:** Modern backend developers are expected to containerize their apps, understand orchestration, and know basic cloud services. This module covers Docker from scratch, Kubernetes essentials, core AWS services, CI/CD pipelines, and observability — everything asked in senior interviews.\r\n\r\n---\r\n\r\n## 8.0 Internal Revision — Deployment Fundamentals\r\n\r\n### What is a Server?\r\n\r\n**Definition:** A computer (physical or virtual) that runs your application and serves requests over a network. When you run `java -jar app.jar` on a machine connected to the internet, that machine is a server.\r\n\r\n### What is \"Deploying\" an Application?\r\n\r\n**Definition:** The process of taking your compiled code and putting it on a server where users can access it. This includes: building the JAR/WAR, copying it to the server, configuring environment variables, starting the application, and routing traffic to it.\r\n\r\n### What is Environment Configuration?\r\n\r\n**Definition:** Different settings for different environments (dev, staging, production) — database URLs, API keys, feature flags, log levels.\r\n\r\n**In plain English:** Your app connects to `localhost:5432` on your laptop but `prod-db.company.com:5432` in production. Environment configuration manages this without changing code.\r\n\r\n```yaml\r\n# Spring Boot profiles\r\n# application-dev.yml\r\nspring:\r\n  datasource:\r\n    url: jdbc:postgresql://localhost:5432/mydb\r\n\r\n# application-prod.yml\r\nspring:\r\n  datasource:\r\n    url: jdbc:postgresql://prod-db.company.com:5432/mydb\r\n\r\n# Activate profile: java -jar app.jar --spring.profiles.active=prod\r\n# Or via environment variable: SPRING_PROFILES_ACTIVE=prod\r\n```\r\n\r\n### What is a JAR vs WAR?\r\n\r\n```\r\nJAR (Java Archive): Standalone package. Contains your app + embedded Tomcat server.\r\n    Run: java -jar app.jar\r\n    Modern Spring Boot default.\r\n\r\nWAR (Web Application Archive): Needs an external app server (Tomcat, WildFly).\r\n    Deploy: copy myapp.war to tomcat/webapps/\r\n    Legacy approach. Avoid in new projects.\r\n```\r\n\r\n---\r\n\r\n## 8.1 Docker\r\n\r\n### What is Docker?\r\n\r\n**Definition:** A platform that packages your application and all its dependencies (JDK, libraries, config) into a standardized unit called a **container**. The container runs identically on any machine that has Docker installed.\r\n\r\n**In plain English:** \"It works on my machine\" → with Docker, your machine\u0027s setup IS the deployment. You package everything into a box (container) and ship the box. It runs the same everywhere — your laptop, staging, production.\r\n\r\n### What is a Container?\r\n\r\n**Definition:** A lightweight, isolated runtime environment that shares the host OS kernel but has its own filesystem, processes, and network. Unlike a virtual machine, containers don\u0027t need a full OS — they\u0027re just isolated processes.\r\n\r\n```\r\nVirtual Machine:                  Container:\r\n┌──────────────┐                 ┌──────────────┐\r\n│   Your App   │                 │   Your App   │\r\n│   Libraries  │                 │   Libraries  │\r\n│   Guest OS   │  ← full OS!    │              │  ← no OS!\r\n│   Hypervisor │                 │   Docker     │\r\n│   Host OS    │                 │   Host OS    │\r\n│   Hardware   │                 │   Hardware   │\r\n└──────────────┘                 └──────────────┘\r\n 500 MB-many GB                   10-200 MB\r\n Minutes to start                 Seconds to start\r\n```\r\n\r\n### What is a Docker Image?\r\n\r\n**Definition:** A read-only template that contains everything needed to run your application: code, runtime (JDK), libraries, environment variables, config files. Think of it as a \"snapshot\" of your application.\r\n\r\n### What is a Dockerfile?\r\n\r\n**Definition:** A text file with instructions to build a Docker image. Each instruction creates a layer.\r\n\r\n```dockerfile\r\n# Multi-stage Dockerfile for Spring Boot\r\n# Stage 1: BUILD\r\nFROM eclipse-temurin:21-jdk AS build\r\nWORKDIR /app\r\nCOPY pom.xml .\r\nCOPY mvnw .\r\nCOPY .mvn .mvn\r\nRUN ./mvnw dependency:resolve            # cache dependencies\r\nCOPY src ./src\r\nRUN ./mvnw package -DskipTests           # build the JAR\r\n\r\n# Stage 2: RUN (smaller image — only JRE, no JDK or source code)\r\nFROM eclipse-temurin:21-jre\r\nRUN addgroup --system appgroup \u0026\u0026 adduser --system --ingroup appgroup appuser\r\nUSER appuser                              # don\u0027t run as root!\r\nCOPY --from=build /app/target/*.jar app.jar\r\nEXPOSE 8080\r\nHEALTHCHECK --interval=30s --timeout=3s CMD curl -f http://localhost:8080/actuator/health || exit 1\r\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\r\n```\r\n\r\n### Docker Commands (Essential)\r\n\r\n```bash\r\ndocker build -t myapp:1.0 .              # build image from Dockerfile\r\ndocker run -p 8080:8080 myapp:1.0         # run container, map port\r\ndocker run -d -p 8080:8080 myapp:1.0      # run in background (detached)\r\ndocker ps                                  # list running containers\r\ndocker logs \u003ccontainer-id\u003e                 # view logs\r\ndocker stop \u003ccontainer-id\u003e                 # stop container\r\ndocker exec -it \u003ccontainer-id\u003e /bin/sh     # shell into container\r\n\r\ndocker images                              # list local images\r\ndocker rmi myapp:1.0                       # remove image\r\n```\r\n\r\n### What is Docker Compose?\r\n\r\n**Definition:** A tool for defining and running multi-container applications. You describe all services (app, database, Redis, Kafka) in one `docker-compose.yml` file and start everything with one command.\r\n\r\n```yaml\r\n# docker-compose.yml\r\nservices:\r\n  app:\r\n    build: .\r\n    ports: [\"8080:8080\"]\r\n    environment:\r\n      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/mydb\r\n      SPRING_DATA_REDIS_HOST: redis\r\n    depends_on: [db, redis]\r\n\r\n  db:\r\n    image: postgres:16\r\n    environment:\r\n      POSTGRES_DB: mydb\r\n      POSTGRES_USER: user\r\n      POSTGRES_PASSWORD: pass\r\n    ports: [\"5432:5432\"]\r\n    volumes: [\"pgdata:/var/lib/postgresql/data\"]   # persist data\r\n\r\n  redis:\r\n    image: redis:7-alpine\r\n    ports: [\"6379:6379\"]\r\n\r\nvolumes:\r\n  pgdata:     # named volume — data survives container restart\r\n```\r\n\r\n```bash\r\ndocker compose up -d       # start all services in background\r\ndocker compose down        # stop and remove all services\r\ndocker compose logs -f app # follow logs of \u0027app\u0027 service\r\n```\r\n\r\n---\r\n\r\n## 8.2 Kubernetes (K8s)\r\n\r\n### What is Kubernetes?\r\n\r\n**Definition:** An open-source container orchestration platform that automates deploying, scaling, and managing containerized applications across a cluster of machines.\r\n\r\n**In plain English:** Docker runs ONE container. Kubernetes runs THOUSANDS of containers across HUNDREDS of servers. It automatically handles: \"Run 5 copies of my app. If one crashes, restart it. If traffic spikes, scale to 10 copies. If a server dies, move containers to healthy servers.\"\r\n\r\n### Core Concepts\r\n\r\n```\r\nPOD:         The smallest deployable unit. Contains one or more containers.\r\n             Usually 1 pod = 1 container of your app.\r\n\r\nDEPLOYMENT:  Defines HOW to run your pods — image, replicas, update strategy.\r\n             \"Run 3 copies of myapp:1.0\"\r\n\r\nSERVICE:     A stable network endpoint to access your pods.\r\n             Pods come and go (scaling, crashes), but the Service has a fixed address.\r\n\r\nCONFIGMAP:   Stores non-sensitive config (feature flags, URLs).\r\n\r\nSECRET:      Stores sensitive config (passwords, API keys). Base64 encoded.\r\n\r\nNAMESPACE:   Logical isolation within a cluster (like folders).\r\n             dev namespace, staging namespace, production namespace.\r\n\r\nINGRESS:     Routes external HTTP traffic to the right Service.\r\n             Maps URLs to services: /api/users → user-service, /api/orders → order-service\r\n```\r\n\r\n### Kubernetes YAML Files\r\n\r\n```yaml\r\n# deployment.yaml\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: order-service\r\nspec:\r\n  replicas: 3                           # run 3 instances\r\n  selector:\r\n    matchLabels:\r\n      app: order-service\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: order-service\r\n    spec:\r\n      containers:\r\n      - name: order-service\r\n        image: myregistry/order-service:1.0\r\n        ports:\r\n        - containerPort: 8080\r\n        resources:\r\n          requests:\r\n            memory: \"256Mi\"\r\n            cpu: \"250m\"\r\n          limits:\r\n            memory: \"512Mi\"\r\n            cpu: \"500m\"\r\n        livenessProbe:                    # is the container alive?\r\n          httpGet:\r\n            path: /actuator/health/liveness\r\n            port: 8080\r\n          initialDelaySeconds: 30\r\n          periodSeconds: 10\r\n        readinessProbe:                   # is the container ready for traffic?\r\n          httpGet:\r\n            path: /actuator/health/readiness\r\n            port: 8080\r\n          initialDelaySeconds: 10\r\n          periodSeconds: 5\r\n        env:\r\n        - name: SPRING_DATASOURCE_URL\r\n          valueFrom:\r\n            secretKeyRef:\r\n              name: db-secrets\r\n              key: url\r\n```\r\n\r\n### What is a Liveness Probe vs Readiness Probe?\r\n\r\n**Liveness:** \"Is the container still running?\" If it fails, K8s RESTARTS the container. Detects deadlocks/hang situations.\r\n\r\n**Readiness:** \"Is the container ready to receive traffic?\" If it fails, K8s stops sending traffic to this pod (but doesn\u0027t restart it). Used during startup or when the pod is temporarily overloaded.\r\n\r\n### Horizontal Pod Autoscaler (HPA)\r\n\r\n```yaml\r\n# Scale between 3-10 pods based on CPU usage\r\napiVersion: autoscaling/v2\r\nkind: HorizontalPodAutoscaler\r\nmetadata:\r\n  name: order-service-hpa\r\nspec:\r\n  scaleTargetRef:\r\n    apiVersion: apps/v1\r\n    kind: Deployment\r\n    name: order-service\r\n  minReplicas: 3\r\n  maxReplicas: 10\r\n  metrics:\r\n  - type: Resource\r\n    resource:\r\n      name: cpu\r\n      target:\r\n        type: Utilization\r\n        averageUtilization: 70    # scale up when CPU \u003e 70%\r\n```\r\n\r\n---\r\n\r\n## 8.3 AWS Core Services for Backend\r\n\r\n### Services You Must Know\r\n\r\n```\r\nCOMPUTE:\r\n  EC2           → Virtual servers (VMs). You manage the OS and everything on it.\r\n  ECS/EKS       → Container orchestration (ECS = AWS-native, EKS = managed Kubernetes)\r\n  Lambda        → Serverless functions. Runs code on demand, pay per execution.\r\n  Elastic Beanstalk → Easy deployment (push code, AWS handles the rest)\r\n\r\nSTORAGE:\r\n  S3            → Object storage. Store files, images, backups. $0.023/GB/month.\r\n  EBS           → Block storage (disk) attached to EC2 instances.\r\n\r\nDATABASE:\r\n  RDS           → Managed relational DB (PostgreSQL, MySQL, Oracle). Handles backups, patches.\r\n  DynamoDB      → Managed NoSQL (key-value). Infinitely scalable. Single-digit ms latency.\r\n  ElastiCache   → Managed Redis or Memcached.\r\n\r\nNETWORKING:\r\n  VPC           → Virtual Private Cloud. Your isolated network in AWS.\r\n  ALB           → Application Load Balancer. Distributes HTTP traffic. Health checks.\r\n  Route 53      → DNS service. Maps domain names to IP addresses.\r\n\r\nMESSAGING:\r\n  SQS           → Simple Queue Service. Managed message queue.\r\n  SNS           → Simple Notification Service. Pub/sub for notifications.\r\n\r\nSECURITY:\r\n  IAM           → Identity and Access Management. Users, roles, permissions.\r\n  Secrets Manager → Store and rotate secrets (DB passwords, API keys).\r\n  KMS           → Key Management Service. Encryption key management.\r\n```\r\n\r\n---\r\n\r\n## 8.4 CI/CD Pipeline\r\n\r\n### What is CI/CD?\r\n\r\n**CI (Continuous Integration):** Automatically build and test code every time a developer pushes to the repo. Catches bugs early.\r\n\r\n**CD (Continuous Delivery/Deployment):**\r\n- Continuous Delivery: automatically prepare code for release (build, test, stage). Manual approval before production.\r\n- Continuous Deployment: automatically deploy to production after all checks pass. No manual approval.\r\n\r\n### GitHub Actions Example\r\n\r\n```yaml\r\n# .github/workflows/ci-cd.yml\r\nname: CI/CD Pipeline\r\n\r\non:\r\n  push:\r\n    branches: [main]\r\n  pull_request:\r\n    branches: [main]\r\n\r\njobs:\r\n  build-and-test:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n    - uses: actions/checkout@v4\r\n\r\n    - name: Set up Java 21\r\n      uses: actions/setup-java@v4\r\n      with:\r\n        java-version: \u002721\u0027\r\n        distribution: \u0027temurin\u0027\r\n\r\n    - name: Build \u0026 Test\r\n      run: ./mvnw clean verify\r\n\r\n    - name: Build Docker Image\r\n      if: github.ref == \u0027refs/heads/main\u0027\r\n      run: docker build -t myapp:${{ github.sha }} .\r\n\r\n    - name: Push to Container Registry\r\n      if: github.ref == \u0027refs/heads/main\u0027\r\n      run: |\r\n        docker tag myapp:${{ github.sha }} myregistry/myapp:${{ github.sha }}\r\n        docker push myregistry/myapp:${{ github.sha }}\r\n\r\n    - name: Deploy to Kubernetes\r\n      if: github.ref == \u0027refs/heads/main\u0027\r\n      run: |\r\n        kubectl set image deployment/myapp myapp=myregistry/myapp:${{ github.sha }}\r\n```\r\n\r\n---\r\n\r\n## 8.5 Observability — The Three Pillars\r\n\r\n### What is Observability?\r\n\r\n**Definition:** The ability to understand what\u0027s happening inside your system by examining its outputs. The three pillars are: Logs, Metrics, and Traces.\r\n\r\n### Logs\r\n\r\n**Definition:** Timestamped text records of events. \"What happened?\"\r\n\r\n```java\r\n// Use structured logging (JSON) — easier to search in ELK/Datadog\r\nlog.info(\"Order created\", Map.of(\"orderId\", order.getId(), \"userId\", order.getUserId()));\r\n// → {\"timestamp\":\"2026-02-13T10:00:00\",\"level\":\"INFO\",\"message\":\"Order created\",\"orderId\":123,\"userId\":456}\r\n```\r\n\r\n**Stack:** Application → Fluentd/Filebeat → Elasticsearch → Kibana (ELK stack)\r\n\r\n### Metrics\r\n\r\n**Definition:** Numerical measurements collected over time. \"How is the system performing?\"\r\n\r\n```\r\nExamples:\r\n  request_count_total          → how many requests?\r\n  request_duration_seconds     → how long do requests take?\r\n  jvm_memory_used_bytes        → how much memory?\r\n  db_connection_pool_active    → how many DB connections used?\r\n  kafka_consumer_lag           → how far behind is the consumer?\r\n```\r\n\r\n**Stack:** Application (Micrometer) → Prometheus (stores metrics) → Grafana (dashboards)\r\n\r\nSpring Boot Actuator exposes metrics automatically:\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: health, metrics, prometheus\r\n```\r\n\r\n### Traces\r\n\r\n**Definition:** A record of a single request\u0027s journey through multiple services. Each service adds a \"span\" to the trace, with timing data.\r\n\r\n```\r\nUser Request → API Gateway (50ms) → Order Service (200ms) → Payment Service (500ms) → DB (100ms)\r\n              ╰─── Trace ID: abc-123 ─────────────────────────────────────────────────╯\r\n\r\nSpan 1: API Gateway     [========]\r\nSpan 2: Order Service   [================================]\r\nSpan 3: Payment Service [====================================================]\r\nSpan 4: DB Query         [==================]\r\n```\r\n\r\n**Stack:** Application (OpenTelemetry SDK) → Jaeger or Zipkin (visualization)\r\n\r\nIn Spring Boot 3.x:\r\n```xml\r\n\u003c!-- pom.xml --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\r\n    \u003cartifactId\u003emicrometer-tracing-bridge-otel\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n```\r\nTrace IDs are automatically propagated across HTTP calls and Kafka messages.\r\n\r\n---\r\n\r\n## 8.6 ✅ What You\u0027ve Learnt After Module 8\r\n\r\n1. **Deployment basics** — JAR vs WAR, environment profiles, Spring Boot profiles\r\n2. **Docker** — images, containers, Dockerfile (multi-stage), docker-compose, essential commands\r\n3. **Docker vs VM** — containers share the kernel, lighter and faster\r\n4. **Kubernetes** — pods, deployments, services, liveness/readiness probes, HPA, YAML manifests\r\n5. **AWS services** — EC2, S3, RDS, SQS, SNS, ALB, IAM, Lambda, DynamoDB, ElastiCache\r\n6. **CI/CD** — GitHub Actions pipeline for build → test → Docker → deploy\r\n7. **Observability** — logs (ELK), metrics (Prometheus/Grafana), traces (OpenTelemetry/Jaeger)\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-9\"\u003e\u003c/a\u003e\r\n# MODULE 9: System Design\r\n\r\n\u003e **What this module is about:** System design rounds are the make-or-break of senior interviews. You\u0027ll be given a vague problem (\"Design a URL shortener\") and must structure a complete solution in 35-45 minutes. This module teaches you the framework, the building blocks, and walks through 10+ real designs.\r\n\r\n---\r\n\r\n## 9.0 Internal Revision — Scalability Fundamentals\r\n\r\n### What is Scalability?\r\n\r\n**Definition:** The ability of a system to handle increased load (more users, more data, more requests) by adding resources.\r\n\r\n### Horizontal vs Vertical Scaling\r\n\r\n**Vertical Scaling (Scale Up):** Add more power to one machine — more CPU, more RAM. Has a physical ceiling.\r\n\r\n**Horizontal Scaling (Scale Out):** Add more machines. No ceiling (theoretically). Preferred for web systems.\r\n\r\n```\r\nVertical:  1 server (16 GB RAM) → 1 server (64 GB RAM)\r\nHorizontal: 1 server → 4 servers behind a load balancer\r\n```\r\n\r\n### What is a Load Balancer?\r\n\r\n**Definition:** A device or software that distributes incoming traffic across multiple servers to ensure no single server is overwhelmed.\r\n\r\n**Algorithms:**\r\n- **Round Robin** — requests go to each server in turn (1, 2, 3, 1, 2, 3...)\r\n- **Least Connections** — send to the server with fewest active connections\r\n- **IP Hash** — same client always goes to the same server (sticky sessions)\r\n- **Weighted** — more powerful servers get more traffic\r\n\r\n### What is a CDN (Content Delivery Network)?\r\n\r\n**Definition:** A globally distributed network of servers that cache static content (images, CSS, JS) close to users, reducing latency.\r\n\r\n**In plain English:** Instead of every user in India fetching an image from a US server (200ms), the image is cached on a server in Mumbai (20ms).\r\n\r\n### What is a Database Index?\r\n\r\nAlready covered in Module 5. Key point for system design: **always mention indexing** when discussing database schema.\r\n\r\n### What is Caching?\r\n\r\nAlready covered in Module 5 (Redis). Key point for system design: mention cache-aside pattern, TTL, and where to cache (client → CDN → application → database).\r\n\r\n### What is a Message Queue?\r\n\r\nAlready covered in Module 6 (Kafka). Key point for system design: use message queues to decouple services and handle async processing (email sending, image processing, notifications).\r\n\r\n### What is a Rate Limiter?\r\n\r\n**Definition:** A mechanism that limits how many requests a user/client can make in a given time window.\r\n\r\n**Algorithms:**\r\n- **Token Bucket:** A bucket holds N tokens. Each request consumes 1 token. Tokens are refilled at a fixed rate. If bucket is empty → reject.\r\n- **Sliding Window Counter:** Count requests in a sliding time window. If count exceeds limit → reject.\r\n\r\n### What is Consistent Hashing?\r\n\r\n**Definition:** A technique to distribute data across multiple servers such that when a server is added or removed, only a minimal amount of data needs to move.\r\n\r\n**In plain English:** Normal hashing: `server = hash(key) % N`. If N changes (add/remove server), EVERYTHING reshuffles. Consistent hashing: organize servers on a ring. Each key goes to the next server clockwise. Adding/removing a server only affects its neighbors.\r\n\r\n---\r\n\r\n## 9.1 The 5-Step System Design Framework\r\n\r\nUse this exact framework in EVERY system design interview:\r\n\r\n```\r\nSTEP 1: REQUIREMENTS (3-5 min)\r\n  - Clarify functional requirements (What does the system do?)\r\n  - Clarify non-functional requirements (Scale? Latency? Availability? Consistency?)\r\n  - Define scope (What is in/out?)\r\n  - Back-of-envelope estimation (users, QPS, storage)\r\n\r\nSTEP 2: HIGH-LEVEL DESIGN (5-10 min)\r\n  - Draw the big boxes: Client → API Gateway → Services → Database/Cache\r\n  - Identify core entities and APIs\r\n  - Sketch the main data flow\r\n\r\nSTEP 3: DATA MODEL \u0026 API DESIGN (5-10 min)\r\n  - Define database tables / schema\r\n  - Define API endpoints (REST/gRPC)\r\n  - Choose SQL vs NoSQL\r\n\r\nSTEP 4: DEEP DIVE (10-15 min)\r\n  - Dive into 2-3 challenging components\r\n  - Discuss trade-offs for each design choice\r\n  - Address bottlenecks, failure scenarios\r\n\r\nSTEP 5: WRAP UP (3-5 min)\r\n  - Summarize trade-offs you made\r\n  - Propose future improvements\r\n  - Mention monitoring/alerting\r\n```\r\n\r\n---\r\n\r\n## 9.2 Back-of-Envelope Estimation\r\n\r\n### Quick Math Cheat Sheet\r\n\r\n```\r\n1 million     = 10^6\r\n1 billion     = 10^9\r\n1 day         = 86,400 seconds ≈ 100,000 seconds (for estimation)\r\n\r\nIf 10 million daily users, each making 5 requests:\r\n  → 50 million requests/day\r\n  → 50M / 100K seconds ≈ 500 QPS (queries per second)\r\n  → Peak (2-3x average) ≈ 1,000-1,500 QPS\r\n\r\nStorage:\r\n  1 KB per record × 10M records/day × 365 days × 5 years\r\n  = 1 KB × 10M × 1,825 ≈ 18 TB total\r\n```\r\n\r\n### Data Size Rules of Thumb\r\n\r\n```\r\n1 character  = 1 byte (ASCII) / 2-4 bytes (Unicode)\r\n1 tweet      ≈ 300 bytes\r\n1 URL        ≈ 100 bytes\r\n1 user record ≈ 1 KB\r\n1 photo      ≈ 200 KB (compressed)\r\n1 short video ≈ 5 MB\r\n```\r\n\r\n---\r\n\r\n## 9.3 System Design — URL Shortener (like bit.ly)\r\n\r\n### Requirements\r\n- Functional: Shorten URL, redirect to original, custom aliases optional, expiration\r\n- Non-functional: 100M URLs/day, read-heavy (100:1 read/write), low latency (\u003c100ms), high availability\r\n\r\n### Estimation\r\n- Writes: 100M/day ≈ 1,200 QPS. Reads: 120,000 QPS (100:1 ratio).\r\n- Storage: 100M × 365 × 5 years × 100 bytes ≈ 18 TB\r\n- Short URL length: 62 chars (a-z, A-Z, 0-9), 7 chars → 62^7 ≈ 3.5 trillion combinations\r\n\r\n### Design\r\n\r\n```\r\nClient → Load Balancer → API Server → Cache (Redis) → Database\r\n\r\nPOST /api/shorten { \"longUrl\": \"https://...\", \"alias\": \"custom123\" }\r\n  → Generate short code (Base62 encoded ID or hash)\r\n  → Save: short_code → long_url in DB\r\n  → Return: https://short.ly/abc1234\r\n\r\nGET /abc1234\r\n  → Look up short_code in cache (Redis)\r\n  → If miss → look up in DB → populate cache\r\n  → Return 301 Redirect to long_url\r\n```\r\n\r\n### Key Decisions\r\n- **ID generation:** Counter (centralized, needs coordination) vs hash (distributed, collision risk). Use a distributed ID generator like Twitter Snowflake.\r\n- **301 vs 302 redirect:** 301 = permanent (browser caches), 302 = temporary (every request hits your server → better analytics). Choose 302.\r\n- **Cache:** LRU cache in Redis for hot URLs. 20% of URLs get 80% of traffic.\r\n\r\n---\r\n\r\n## 9.4 System Design — Rate Limiter\r\n\r\n### Requirements\r\n- Limit requests per user/IP/API-key\r\n- Configurable rules (100 req/min for free tier, 1000 for paid)\r\n- Return 429 Too Many Requests when limit exceeded\r\n\r\n### Design — Token Bucket (preferred)\r\n\r\n```\r\nRequest → Rate Limiter Middleware → Application\r\n\r\nFor each user/key:\r\n  Redis: RATE_LIMIT:user123 = { tokens: 95, lastRefill: 1707836400 }\r\n  \r\n  On request:\r\n    1. Calculate tokens to add since lastRefill (rate × elapsed time)\r\n    2. If tokens \u003e 0: allow request, decrement token count\r\n    3. If tokens = 0: reject with 429, return Retry-After header\r\n```\r\n\r\n```java\r\n// Spring Boot filter\r\n@Component\r\npublic class RateLimitFilter extends OncePerRequestFilter {\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res,\r\n                                     FilterChain chain) throws IOException, ServletException {\r\n        String key = \"RATE:\" + req.getRemoteAddr();\r\n        Long count = redis.opsForValue().increment(key);\r\n        if (count == 1) redis.expire(key, 60, TimeUnit.SECONDS);\r\n\r\n        if (count \u003e 100) {\r\n            res.setStatus(429);\r\n            res.getWriter().write(\"Rate limit exceeded\");\r\n            return;\r\n        }\r\n        chain.doFilter(req, res);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 9.5 System Design — Chat System (like WhatsApp)\r\n\r\n### Requirements\r\n- 1:1 messaging, group messaging (up to 500 members)\r\n- Online/offline status\r\n- Read receipts, delivered status\r\n- Message storage and search\r\n\r\n### Design\r\n\r\n```\r\nClient ←WebSocket→ Chat Server → Message Queue (Kafka) → Recipient\u0027s Chat Server → Recipient\r\n\r\nMessage Flow:\r\n  1. Alice sends message → WebSocket to her Chat Server\r\n  2. Server stores message in DB (status: SENT)\r\n  3. Server publishes to Kafka topic: \"messages\"\r\n  4. Bob\u0027s Chat Server consumes the message\r\n     - If Bob is ONLINE → push via WebSocket (status: DELIVERED)\r\n     - If Bob is OFFLINE → store in pending queue, push via APNs/FCM\r\n  5. Bob reads the message → send ACK back via WebSocket (status: READ)\r\n\r\nPresence Service:\r\n  - WebSocket heartbeat every 5 seconds\r\n  - If no heartbeat for 30s → mark user OFFLINE\r\n  - Store in Redis: USER_STATUS:bob = {status: \"ONLINE\", lastSeen: 1707836400}\r\n```\r\n\r\n### Group Messages\r\n- Fan-out: when Alice sends to group (100 members), create 100 message entries? Expensive write.\r\n- Better: store ONE message, maintain group membership, pull-based read for large groups.\r\n\r\n---\r\n\r\n## 9.6 System Design — Notification System\r\n\r\n### Requirements\r\n- Support push (mobile), SMS, email\r\n- Priority levels (urgent vs batch)\r\n- Rate limiting per user (don\u0027t spam)\r\n\r\n### Design\r\n\r\n```\r\nEvent Sources → Notification Service → Priority Queue → Workers → Delivery (APNs/FCM/SMTP/SMS)\r\n\r\nDB tables:\r\n  notifications:     id, user_id, type, channel, status, content, created_at\r\n  user_preferences:  user_id, email_enabled, push_enabled, sms_enabled, quiet_hours\r\n  templates:         id, name, body_template, channel\r\n```\r\n\r\n---\r\n\r\n## 9.7 System Design — Payment System\r\n\r\n### Requirements\r\n- Process payments reliably (ZERO data loss)\r\n- Handle double charges (idempotency)\r\n- Support multiple payment methods\r\n\r\n### Design Principles\r\n- **Idempotency key** on every payment request (Module 7.5)\r\n- **Exactly-once processing** via database transaction + idempotency table\r\n- **Event sourcing** for audit trail (every state change is an event)\r\n- **Reconciliation job** that compares internal records with payment gateway records daily\r\n\r\n```\r\nClient → API (idempotency check) → Payment Service → Payment Gateway (Stripe/Razorpay)\r\n                                      ↓\r\n                              Payment Ledger (append-only)\r\n                                      ↓\r\n                              Kafka event → Order Service, Invoice Service\r\n```\r\n\r\n---\r\n\r\n## 9.8 More System Design Topics (Brief Approach)\r\n\r\n### Design a News Feed (Facebook/Twitter)\r\n- **Push model (fan-out on write):** When a user posts, push to all followers\u0027 feeds. Fast read, expensive write. Good for users with \u003c 1000 followers.\r\n- **Pull model (fan-out on read):** When user opens feed, pull posts from all followed users. Slow read, cheap write. Good for celebrities (millions of followers).\r\n- **Hybrid:** Push for most users, pull for celebrities.\r\n\r\n### Design a File Storage System (Google Drive/Dropbox)\r\n- Chunk files into 4MB blocks → deduplicate → store in object storage (S3)\r\n- Sync via long polling or WebSocket\r\n- Conflict resolution: last-writer-wins or manual merge\r\n\r\n### Design a Search Autocomplete\r\n- Trie data structure or Elasticsearch prefix queries\r\n- Aggregate top searches per prefix in Redis\r\n- Update asynchronously (not on every keystroke)\r\n\r\n### Design a Distributed Cache\r\n- Consistent hashing to distribute keys across cache nodes\r\n- Replication for fault tolerance\r\n- Eviction policy: LRU (Least Recently Used)\r\n\r\n---\r\n\r\n## 9.9 ✅ What You\u0027ve Learnt After Module 9\r\n\r\n1. **5-step framework** — Requirements → High-Level → Data Model → Deep Dive → Wrap Up\r\n2. **Back-of-envelope math** — QPS, storage, data size estimation\r\n3. **Building blocks** — load balancer, CDN, cache, queue, consistent hashing, rate limiter\r\n4. **URL shortener** — ID generation, Base62, 301 vs 302, caching hot URLs\r\n5. **Rate limiter** — token bucket, sliding window, Redis implementation\r\n6. **Chat system** — WebSocket, presence, message delivery states, fan-out\r\n7. **Payment system** — idempotency, exactly-once, event sourcing, reconciliation\r\n8. **News feed** — push vs pull vs hybrid model\r\n9. **File storage, autocomplete, distributed cache** — key approaches\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-10\"\u003e\u003c/a\u003e\r\n# MODULE 10: Low-Level Design (LLD) \u0026 Design Patterns\r\n\r\n\u003e **What this module is about:** LLD rounds test your ability to write clean, extensible object-oriented code. You\u0027ll be asked to design classes for a parking lot, ride-sharing app, or elevator system. This module covers SOLID principles, the most-asked design patterns with Java code, and LLD practice.\r\n\r\n---\r\n\r\n## 10.0 Internal Revision — OOP Basics\r\n\r\n### What are the 4 Pillars of OOP?\r\n\r\n**Encapsulation:** Bundling data (fields) and methods that operate on that data into a single class, and hiding internal details using access modifiers (`private`, `protected`).\r\n\r\n**Abstraction:** Presenting only the essential features and hiding implementation details. Achieved via abstract classes and interfaces.\r\n\r\n**Inheritance:** Creating new classes from existing ones, reusing and extending behavior. `class Dog extends Animal`.\r\n\r\n**Polymorphism:** One interface, many implementations. A `Shape` reference can hold a `Circle`, `Rectangle`, or `Triangle`, and calling `draw()` executes the correct version.\r\n\r\n### What is an Interface vs Abstract Class?\r\n\r\n| Feature | Interface | Abstract Class |\r\n|---------|-----------|---------------|\r\n| Methods | Abstract + default (Java 8+) | Abstract + concrete |\r\n| Fields | Only constants (`static final`) | Instance fields allowed |\r\n| Constructor | No | Yes |\r\n| Multiple inheritance | Yes (implement many interfaces) | No (extend only one class) |\r\n| Use when | Defining a contract/capability | Sharing code among related classes |\r\n\r\n---\r\n\r\n## 10.1 SOLID Principles\r\n\r\n### S — Single Responsibility Principle\r\n\r\n**Definition:** A class should have only ONE reason to change. Each class does one job.\r\n\r\n```java\r\n// ❌ BAD: UserService handles users AND email sending\r\nclass UserService {\r\n    void createUser(User u) { /* save user */ }\r\n    void sendWelcomeEmail(User u) { /* send email */ }\r\n}\r\n\r\n// ✅ GOOD: separate responsibilities\r\nclass UserService {\r\n    void createUser(User u) { /* save user */ }\r\n}\r\nclass EmailService {\r\n    void sendWelcomeEmail(User u) { /* send email */ }\r\n}\r\n```\r\n\r\n### O — Open/Closed Principle\r\n\r\n**Definition:** Classes should be OPEN for extension but CLOSED for modification. Add new behavior without changing existing code.\r\n\r\n```java\r\n// ❌ BAD: adding a new shape requires modifying this method\r\ndouble area(Object shape) {\r\n    if (shape instanceof Circle c) return Math.PI * c.radius * c.radius;\r\n    if (shape instanceof Rectangle r) return r.width * r.height;\r\n    // Adding Triangle means changing this method!\r\n}\r\n\r\n// ✅ GOOD: new shapes just implement the interface\r\ninterface Shape { double area(); }\r\nclass Circle implements Shape { double area() { return Math.PI * r * r; } }\r\nclass Triangle implements Shape { double area() { return 0.5 * base * height; } }\r\n// Adding a new shape = new class. Zero changes to existing code.\r\n```\r\n\r\n### L — Liskov Substitution Principle\r\n\r\n**Definition:** Subtypes must be substitutable for their base types. If code works with `Animal`, it must also work with `Dog` (a subclass of Animal) without breaking.\r\n\r\n```java\r\n// ❌ VIOLATION: Square overrides setWidth to also set height — breaks Rectangle\u0027s contract\r\nclass Rectangle {\r\n    void setWidth(int w) { this.width = w; }\r\n    void setHeight(int h) { this.height = h; }\r\n}\r\nclass Square extends Rectangle {\r\n    void setWidth(int w) { this.width = w; this.height = w; }  // surprise!\r\n}\r\n```\r\n\r\n### I — Interface Segregation Principle\r\n\r\n**Definition:** Don\u0027t force clients to depend on interfaces they don\u0027t use. Prefer many small interfaces over one large one.\r\n\r\n```java\r\n// ❌ BAD: PrinterScanner forces all implementations to implement scan\r\ninterface PrinterScanner { void print(); void scan(); }\r\nclass SimplePrinter implements PrinterScanner {\r\n    void print() { /* OK */ }\r\n    void scan() { throw new UnsupportedOperationException(); }  // forced!\r\n}\r\n\r\n// ✅ GOOD: separate interfaces\r\ninterface Printer { void print(); }\r\ninterface Scanner { void scan(); }\r\nclass SimplePrinter implements Printer { void print() { /* OK */ } }\r\nclass MultiDevice implements Printer, Scanner { /* implements both */ }\r\n```\r\n\r\n### D — Dependency Inversion Principle\r\n\r\n**Definition:** High-level modules should not depend on low-level modules. Both should depend on abstractions (interfaces).\r\n\r\n```java\r\n// ❌ BAD: OrderService directly depends on MySQLRepository (concrete class)\r\nclass OrderService {\r\n    private MySQLRepository repo = new MySQLRepository();\r\n}\r\n\r\n// ✅ GOOD: depend on interface, inject implementation\r\nclass OrderService {\r\n    private final OrderRepository repo;  // interface!\r\n    OrderService(OrderRepository repo) { this.repo = repo; }\r\n}\r\n// Spring injects the implementation: @Autowired constructor injection\r\n```\r\n\r\n---\r\n\r\n## 10.2 Design Patterns — Strategy\r\n\r\n### What is the Strategy Pattern?\r\n\r\n**Definition:** Define a family of algorithms, encapsulate each one, and make them interchangeable at runtime. The client chooses which strategy to use.\r\n\r\n**When to use:** Multiple ways to do the same thing (payment methods, sorting algorithms, notification channels).\r\n\r\n```java\r\n// Strategy interface\r\ninterface PaymentStrategy {\r\n    void pay(BigDecimal amount);\r\n}\r\n\r\n// Concrete strategies\r\nclass CreditCardPayment implements PaymentStrategy {\r\n    public void pay(BigDecimal amount) { System.out.println(\"Paid \" + amount + \" via Credit Card\"); }\r\n}\r\nclass UPIPayment implements PaymentStrategy {\r\n    public void pay(BigDecimal amount) { System.out.println(\"Paid \" + amount + \" via UPI\"); }\r\n}\r\n\r\n// Context\r\nclass PaymentService {\r\n    private PaymentStrategy strategy;\r\n    void setStrategy(PaymentStrategy strategy) { this.strategy = strategy; }\r\n    void checkout(BigDecimal amount) { strategy.pay(amount); }\r\n}\r\n\r\n// Usage\r\nvar service = new PaymentService();\r\nservice.setStrategy(new UPIPayment());\r\nservice.checkout(new BigDecimal(\"499.99\"));\r\n```\r\n\r\n---\r\n\r\n## 10.3 Design Patterns — Builder\r\n\r\n### What is the Builder Pattern?\r\n\r\n**Definition:** Separate the construction of a complex object from its representation. Allows step-by-step creation with fluent syntax.\r\n\r\n**When to use:** Objects with many optional parameters (instead of telescoping constructors).\r\n\r\n```java\r\npublic class User {\r\n    private final String name;       // required\r\n    private final String email;      // required\r\n    private final String phone;      // optional\r\n    private final int age;           // optional\r\n\r\n    private User(Builder builder) {\r\n        this.name = builder.name;\r\n        this.email = builder.email;\r\n        this.phone = builder.phone;\r\n        this.age = builder.age;\r\n    }\r\n\r\n    public static class Builder {\r\n        private final String name;\r\n        private final String email;\r\n        private String phone;\r\n        private int age;\r\n\r\n        public Builder(String name, String email) {\r\n            this.name = name; this.email = email;\r\n        }\r\n        public Builder phone(String phone) { this.phone = phone; return this; }\r\n        public Builder age(int age) { this.age = age; return this; }\r\n        public User build() { return new User(this); }\r\n    }\r\n}\r\n\r\n// Usage\r\nUser user = new User.Builder(\"Alice\", \"alice@example.com\")\r\n    .phone(\"+91-9876543210\")\r\n    .age(30)\r\n    .build();\r\n```\r\n\r\n**Shortcut with Lombok:** `@Builder` annotation generates all of this automatically.\r\n\r\n---\r\n\r\n## 10.4 Design Patterns — Observer\r\n\r\n### What is the Observer Pattern?\r\n\r\n**Definition:** When one object (subject) changes state, all its dependents (observers) are notified automatically. One-to-many dependency.\r\n\r\n**When to use:** Event listeners, notification systems, UI updates.\r\n\r\n```java\r\ninterface EventListener {\r\n    void onEvent(String eventType, String data);\r\n}\r\n\r\nclass EventBus {\r\n    private Map\u003cString, List\u003cEventListener\u003e\u003e listeners = new HashMap\u003c\u003e();\r\n\r\n    void subscribe(String eventType, EventListener listener) {\r\n        listeners.computeIfAbsent(eventType, k -\u003e new ArrayList\u003c\u003e()).add(listener);\r\n    }\r\n\r\n    void publish(String eventType, String data) {\r\n        listeners.getOrDefault(eventType, List.of())\r\n                 .forEach(l -\u003e l.onEvent(eventType, data));\r\n    }\r\n}\r\n\r\n// Usage\r\nvar bus = new EventBus();\r\nbus.subscribe(\"ORDER_CREATED\", (type, data) -\u003e sendEmail(data));\r\nbus.subscribe(\"ORDER_CREATED\", (type, data) -\u003e updateInventory(data));\r\nbus.publish(\"ORDER_CREATED\", \"order-123\");   // both handlers fire\r\n```\r\n\r\n**In Spring:** This is exactly how `@EventListener` and `ApplicationEventPublisher` work!\r\n\r\n---\r\n\r\n## 10.5 Design Patterns — Factory\r\n\r\n### What is the Factory Pattern?\r\n\r\n**Definition:** A creational pattern that provides a method for creating objects without specifying the exact class. The factory decides which class to instantiate based on input.\r\n\r\n```java\r\ninterface Notification { void send(String message); }\r\n\r\nclass EmailNotification implements Notification {\r\n    public void send(String message) { System.out.println(\"Email: \" + message); }\r\n}\r\nclass SMSNotification implements Notification {\r\n    public void send(String message) { System.out.println(\"SMS: \" + message); }\r\n}\r\nclass PushNotification implements Notification {\r\n    public void send(String message) { System.out.println(\"Push: \" + message); }\r\n}\r\n\r\nclass NotificationFactory {\r\n    static Notification create(String channel) {\r\n        return switch (channel) {\r\n            case \"email\" -\u003e new EmailNotification();\r\n            case \"sms\"   -\u003e new SMSNotification();\r\n            case \"push\"  -\u003e new PushNotification();\r\n            default      -\u003e throw new IllegalArgumentException(\"Unknown: \" + channel);\r\n        };\r\n    }\r\n}\r\n\r\n// Usage\r\nNotification n = NotificationFactory.create(\"email\");\r\nn.send(\"Hello!\");\r\n```\r\n\r\n---\r\n\r\n## 10.6 Design Patterns — Singleton\r\n\r\n### What is the Singleton Pattern?\r\n\r\n**Definition:** Ensures a class has exactly ONE instance and provides a global access point to it.\r\n\r\n```java\r\n// Thread-safe Singleton (Bill Pugh method — best approach)\r\npublic class ConfigManager {\r\n    private ConfigManager() {}   // private constructor\r\n\r\n    private static class Holder {\r\n        private static final ConfigManager INSTANCE = new ConfigManager();\r\n    }\r\n\r\n    public static ConfigManager getInstance() {\r\n        return Holder.INSTANCE;   // loaded lazily, thread-safe by JVM classloader\r\n    }\r\n}\r\n```\r\n\r\n**In Spring:** Every `@Bean` and `@Service` is a singleton by default! Spring manages the lifecycle — you rarely need to implement Singleton yourself.\r\n\r\n---\r\n\r\n## 10.7 Design Patterns — Decorator\r\n\r\n### What is the Decorator Pattern?\r\n\r\n**Definition:** Dynamically add new behavior to an object by wrapping it. Each wrapper (decorator) adds one responsibility while delegating to the wrapped object.\r\n\r\n**When to use:** Adding features (logging, caching, encryption) without modifying the original class.\r\n\r\n```java\r\ninterface DataSource {\r\n    String read();\r\n    void write(String data);\r\n}\r\n\r\nclass FileDataSource implements DataSource {\r\n    public String read() { return \"raw file data\"; }\r\n    public void write(String data) { /* write to file */ }\r\n}\r\n\r\nclass EncryptionDecorator implements DataSource {\r\n    private final DataSource wrapped;\r\n    EncryptionDecorator(DataSource wrapped) { this.wrapped = wrapped; }\r\n    public String read() { return decrypt(wrapped.read()); }\r\n    public void write(String data) { wrapped.write(encrypt(data)); }\r\n}\r\n\r\nclass CompressionDecorator implements DataSource {\r\n    private final DataSource wrapped;\r\n    CompressionDecorator(DataSource wrapped) { this.wrapped = wrapped; }\r\n    public String read() { return decompress(wrapped.read()); }\r\n    public void write(String data) { wrapped.write(compress(data)); }\r\n}\r\n\r\n// Usage: stack decorators\r\nDataSource source = new CompressionDecorator(\r\n                        new EncryptionDecorator(\r\n                            new FileDataSource()));\r\nsource.write(\"secret data\");   // compress → encrypt → write to file\r\n```\r\n\r\n**Real-world Java examples:** `BufferedReader(new InputStreamReader(new FileInputStream(...)))` — classic decorator chain!\r\n\r\n---\r\n\r\n## 10.8 LLD Practice Problem — Parking Lot\r\n\r\n```java\r\n// Entities\r\nenum VehicleSize { SMALL, MEDIUM, LARGE }\r\n\r\nclass Vehicle {\r\n    String licensePlate;\r\n    VehicleSize size;\r\n}\r\n\r\nclass ParkingSpot {\r\n    int spotId;\r\n    VehicleSize size;\r\n    boolean isOccupied;\r\n    Vehicle currentVehicle;\r\n\r\n    boolean canFit(Vehicle v) { return !isOccupied \u0026\u0026 v.size.ordinal() \u003c= this.size.ordinal(); }\r\n    void park(Vehicle v) { this.currentVehicle = v; this.isOccupied = true; }\r\n    void vacate() { this.currentVehicle = null; this.isOccupied = false; }\r\n}\r\n\r\nclass ParkingFloor {\r\n    int floorNumber;\r\n    List\u003cParkingSpot\u003e spots;\r\n\r\n    Optional\u003cParkingSpot\u003e findSpot(Vehicle v) {\r\n        return spots.stream().filter(s -\u003e s.canFit(v)).findFirst();\r\n    }\r\n}\r\n\r\nclass ParkingLot {\r\n    List\u003cParkingFloor\u003e floors;\r\n\r\n    ParkingTicket parkVehicle(Vehicle v) {\r\n        for (ParkingFloor floor : floors) {\r\n            Optional\u003cParkingSpot\u003e spot = floor.findSpot(v);\r\n            if (spot.isPresent()) {\r\n                spot.get().park(v);\r\n                return new ParkingTicket(v, spot.get(), Instant.now());\r\n            }\r\n        }\r\n        throw new ParkingFullException(\"No available spot for \" + v.size);\r\n    }\r\n\r\n    BigDecimal unparkVehicle(ParkingTicket ticket) {\r\n        ticket.getSpot().vacate();\r\n        Duration parked = Duration.between(ticket.getEntryTime(), Instant.now());\r\n        return calculateFee(parked, ticket.getSpot().getSize());\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 10.9 ✅ What You\u0027ve Learnt After Module 10\r\n\r\n1. **OOP pillars** — Encapsulation, Abstraction, Inheritance, Polymorphism\r\n2. **SOLID** — Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion\r\n3. **Strategy** — interchangeable algorithms at runtime\r\n4. **Builder** — step-by-step object construction with fluent API\r\n5. **Observer** — publish events, multiple subscribers notified\r\n6. **Factory** — create objects without specifying exact class\r\n7. **Singleton** — exactly one instance (Spring does this for you)\r\n8. **Decorator** — wrap to add behavior dynamically\r\n9. **LLD approach** — identify entities → define relationships → code clean classes\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-11\"\u003e\u003c/a\u003e\r\n# MODULE 11: Data Structures \u0026 Algorithms (DSA) for Interviews\r\n\r\n\u003e **What this module is about:** For 7+ YoE candidates, DSA rounds are typically medium-difficulty. No competitive programming gymnastics — just solid problem-solving. This module covers the 13 most important patterns with Java code and the data structures behind them.\r\n\r\n---\r\n\r\n## 11.0 Internal Revision — Java Collections for DSA\r\n\r\n### What are Java Collections?\r\n\r\n**Definition:** The Java Collections Framework is a set of interfaces and classes for storing and manipulating groups of data: lists, sets, maps, queues, and stacks.\r\n\r\n### Which to use when?\r\n\r\n```\r\nArray / ArrayList    → indexed access, dynamic size. O(1) get, O(n) insert in middle.\r\nLinkedList           → fast insert/delete at head/tail. O(n) random access. Rarely needed.\r\nHashMap              → key-value lookup. O(1) average for get/put. Unordered.\r\nLinkedHashMap        → like HashMap but maintains insertion order.\r\nTreeMap              → sorted keys. O(log n) for get/put. Implements NavigableMap.\r\nHashSet              → unique elements. O(1) add/contains. Unordered.\r\nTreeSet              → sorted unique elements. O(log n).\r\nPriorityQueue        → min-heap by default. O(log n) add/poll. O(1) peek.\r\nDeque (ArrayDeque)   → double-ended queue. Use as stack or queue. O(1) at both ends.\r\nStack                → LIFO. Use ArrayDeque instead (Stack is legacy).\r\nQueue (LinkedList)   → FIFO. Use ArrayDeque instead.\r\n```\r\n\r\n### Big-O Complexity Summary\r\n\r\n```\r\nO(1)       → constant. HashMap get/put, array index access\r\nO(log n)   → logarithmic. Binary search, TreeMap operations\r\nO(n)       → linear. Single loop through array\r\nO(n log n) → linearithmic. Efficient sorting (merge sort, Arrays.sort)\r\nO(n²)      → quadratic. Nested loops. Bubble/insertion sort. AVOID for large n.\r\nO(2^n)     → exponential. Brute-force subsets. BAD.\r\n```\r\n\r\n---\r\n\r\n## 11.1 Pattern: Two Pointers\r\n\r\n**When to use:** Sorted arrays, finding pairs, removing duplicates, palindrome checks.\r\n\r\n```java\r\n// Find two numbers that sum to target (sorted array)\r\nint[] twoSum(int[] nums, int target) {\r\n    int left = 0, right = nums.length - 1;\r\n    while (left \u003c right) {\r\n        int sum = nums[left] + nums[right];\r\n        if (sum == target) return new int[]{left, right};\r\n        else if (sum \u003c target) left++;\r\n        else right--;\r\n    }\r\n    return new int[]{};  // no pair found\r\n}\r\n// O(n) time, O(1) space\r\n```\r\n\r\n---\r\n\r\n## 11.2 Pattern: Sliding Window\r\n\r\n**When to use:** Subarrays/substrings of fixed or variable size — max sum, longest substring, anagram detection.\r\n\r\n```java\r\n// Longest substring without repeating characters\r\nint lengthOfLongestSubstring(String s) {\r\n    Map\u003cCharacter, Integer\u003e seen = new HashMap\u003c\u003e();\r\n    int maxLen = 0, left = 0;\r\n\r\n    for (int right = 0; right \u003c s.length(); right++) {\r\n        char c = s.charAt(right);\r\n        if (seen.containsKey(c) \u0026\u0026 seen.get(c) \u003e= left) {\r\n            left = seen.get(c) + 1;   // shrink window\r\n        }\r\n        seen.put(c, right);\r\n        maxLen = Math.max(maxLen, right - left + 1);\r\n    }\r\n    return maxLen;\r\n}\r\n// O(n) time, O(min(n, 26)) space\r\n```\r\n\r\n---\r\n\r\n## 11.3 Pattern: Stack\r\n\r\n**When to use:** Matching brackets, next greater element, expression evaluation, undo operations.\r\n\r\n```java\r\n// Valid parentheses: {[()]}\r\nboolean isValid(String s) {\r\n    Deque\u003cCharacter\u003e stack = new ArrayDeque\u003c\u003e();\r\n    Map\u003cCharacter, Character\u003e pairs = Map.of(\u0027)\u0027, \u0027(\u0027, \u0027]\u0027, \u0027[\u0027, \u0027}\u0027, \u0027{\u0027);\r\n\r\n    for (char c : s.toCharArray()) {\r\n        if (pairs.containsValue(c)) {\r\n            stack.push(c);           // opening bracket\r\n        } else {\r\n            if (stack.isEmpty() || stack.pop() != pairs.get(c)) return false;\r\n        }\r\n    }\r\n    return stack.isEmpty();\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11.4 Pattern: Binary Search\r\n\r\n**When to use:** Sorted arrays, search space reduction, finding boundaries (first/last occurrence).\r\n\r\n```java\r\n// Find first occurrence of target\r\nint firstOccurrence(int[] nums, int target) {\r\n    int left = 0, right = nums.length - 1, result = -1;\r\n    while (left \u003c= right) {\r\n        int mid = left + (right - left) / 2;   // avoid overflow\r\n        if (nums[mid] == target) {\r\n            result = mid;\r\n            right = mid - 1;    // keep searching LEFT for earlier occurrence\r\n        } else if (nums[mid] \u003c target) left = mid + 1;\r\n        else right = mid - 1;\r\n    }\r\n    return result;\r\n}\r\n// O(log n) time\r\n```\r\n\r\n---\r\n\r\n## 11.5 Pattern: HashMap / Frequency Count\r\n\r\n**When to use:** Counting occurrences, checking anagrams, finding duplicates, two-sum (unsorted).\r\n\r\n```java\r\n// Two Sum (unsorted) — THE most famous interview question\r\nint[] twoSum(int[] nums, int target) {\r\n    Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();  // value → index\r\n    for (int i = 0; i \u003c nums.length; i++) {\r\n        int complement = target - nums[i];\r\n        if (map.containsKey(complement)) {\r\n            return new int[]{map.get(complement), i};\r\n        }\r\n        map.put(nums[i], i);\r\n    }\r\n    return new int[]{};\r\n}\r\n// O(n) time, O(n) space\r\n```\r\n\r\n---\r\n\r\n## 11.6 Pattern: Trees (BFS / DFS)\r\n\r\n**When to use:** Tree traversal, depth/height, path sums, level-order operations.\r\n\r\n```java\r\n// Maximum depth of a binary tree (DFS)\r\nint maxDepth(TreeNode root) {\r\n    if (root == null) return 0;\r\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n}\r\n\r\n// Level-order traversal (BFS)\r\nList\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) {\r\n    List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e();\r\n    if (root == null) return result;\r\n\r\n    Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e();\r\n    queue.offer(root);\r\n\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        List\u003cInteger\u003e level = new ArrayList\u003c\u003e();\r\n        for (int i = 0; i \u003c size; i++) {\r\n            TreeNode node = queue.poll();\r\n            level.add(node.val);\r\n            if (node.left != null) queue.offer(node.left);\r\n            if (node.right != null) queue.offer(node.right);\r\n        }\r\n        result.add(level);\r\n    }\r\n    return result;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11.7 Pattern: Graphs (BFS / DFS)\r\n\r\n**When to use:** Shortest path, connected components, cycle detection, topological sort.\r\n\r\n```java\r\n// BFS — shortest path in unweighted graph\r\nint shortestPath(Map\u003cInteger, List\u003cInteger\u003e\u003e graph, int source, int target) {\r\n    Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e();\r\n    Set\u003cInteger\u003e visited = new HashSet\u003c\u003e();\r\n    queue.offer(source);\r\n    visited.add(source);\r\n    int distance = 0;\r\n\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        for (int i = 0; i \u003c size; i++) {\r\n            int node = queue.poll();\r\n            if (node == target) return distance;\r\n            for (int neighbor : graph.getOrDefault(node, List.of())) {\r\n                if (!visited.contains(neighbor)) {\r\n                    visited.add(neighbor);\r\n                    queue.offer(neighbor);\r\n                }\r\n            }\r\n        }\r\n        distance++;\r\n    }\r\n    return -1;  // unreachable\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11.8 Pattern: Dynamic Programming (DP)\r\n\r\n**When to use:** Overlapping subproblems + optimal substructure. \"Minimum/maximum\", \"number of ways\", \"is it possible\".\r\n\r\n### Steps to Solve DP\r\n\r\n```\r\n1. Define the state: dp[i] = what does index i represent?\r\n2. Define transition: dp[i] depends on dp[i-1], dp[i-2], etc.\r\n3. Define base case: dp[0] = ?, dp[1] = ?\r\n4. Decide direction: bottom-up (iterative) or top-down (recursion + memo)\r\n```\r\n\r\n```java\r\n// Climbing stairs: how many ways to reach step n (1 or 2 steps at a time)?\r\nint climbStairs(int n) {\r\n    if (n \u003c= 2) return n;\r\n    int prev2 = 1, prev1 = 2;\r\n    for (int i = 3; i \u003c= n; i++) {\r\n        int curr = prev1 + prev2;  // dp[i] = dp[i-1] + dp[i-2]\r\n        prev2 = prev1;\r\n        prev1 = curr;\r\n    }\r\n    return prev1;\r\n}\r\n// O(n) time, O(1) space\r\n\r\n// Longest Common Subsequence (LCS) — classic 2D DP\r\nint lcs(String s1, String s2) {\r\n    int m = s1.length(), n = s2.length();\r\n    int[][] dp = new int[m + 1][n + 1];\r\n\r\n    for (int i = 1; i \u003c= m; i++) {\r\n        for (int j = 1; j \u003c= n; j++) {\r\n            if (s1.charAt(i-1) == s2.charAt(j-1))\r\n                dp[i][j] = dp[i-1][j-1] + 1;\r\n            else\r\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\r\n        }\r\n    }\r\n    return dp[m][n];\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11.9 Pattern: Heap / Priority Queue\r\n\r\n**When to use:** Top-K elements, K-th largest, merge K sorted lists, scheduling.\r\n\r\n```java\r\n// Kth largest element\r\nint findKthLargest(int[] nums, int k) {\r\n    PriorityQueue\u003cInteger\u003e minHeap = new PriorityQueue\u003c\u003e();  // min-heap of size k\r\n    for (int num : nums) {\r\n        minHeap.offer(num);\r\n        if (minHeap.size() \u003e k) minHeap.poll();   // remove smallest\r\n    }\r\n    return minHeap.peek();   // k-th largest is the smallest in the min-heap\r\n}\r\n// O(n log k) time\r\n```\r\n\r\n---\r\n\r\n## 11.10 More Patterns (Quick Reference)\r\n\r\n### Backtracking\r\n```java\r\n// Generate all permutations\r\nvoid permute(int[] nums, List\u003cInteger\u003e current, boolean[] used, List\u003cList\u003cInteger\u003e\u003e result) {\r\n    if (current.size() == nums.length) { result.add(new ArrayList\u003c\u003e(current)); return; }\r\n    for (int i = 0; i \u003c nums.length; i++) {\r\n        if (used[i]) continue;\r\n        used[i] = true;\r\n        current.add(nums[i]);\r\n        permute(nums, current, used, result);\r\n        current.remove(current.size() - 1);   // backtrack\r\n        used[i] = false;\r\n    }\r\n}\r\n```\r\n\r\n### Prefix Sum\r\n```java\r\n// Subarray sum equals K — count subarrays\r\nint subarraySum(int[] nums, int k) {\r\n    Map\u003cInteger, Integer\u003e prefixCount = new HashMap\u003c\u003e();\r\n    prefixCount.put(0, 1);\r\n    int sum = 0, count = 0;\r\n    for (int num : nums) {\r\n        sum += num;\r\n        count += prefixCount.getOrDefault(sum - k, 0);\r\n        prefixCount.merge(sum, 1, Integer::sum);\r\n    }\r\n    return count;\r\n}\r\n```\r\n\r\n### Intervals\r\n```java\r\n// Merge overlapping intervals\r\nint[][] merge(int[][] intervals) {\r\n    Arrays.sort(intervals, Comparator.comparingInt(a -\u003e a[0]));\r\n    List\u003cint[]\u003e merged = new ArrayList\u003c\u003e();\r\n    for (int[] interval : intervals) {\r\n        if (merged.isEmpty() || merged.getLast()[1] \u003c interval[0]) {\r\n            merged.add(interval);\r\n        } else {\r\n            merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);\r\n        }\r\n    }\r\n    return merged.toArray(new int[0][]);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11.11 ✅ What You\u0027ve Learnt After Module 11\r\n\r\n1. **Collections** — ArrayList, HashMap, TreeMap, PriorityQueue, Deque — when to use each\r\n2. **Big-O** — time/space complexity analysis\r\n3. **Two Pointers** — sorted array pair finding, palindromes\r\n4. **Sliding Window** — subarray/substring problems\r\n5. **Stack** — bracket matching, next greater element\r\n6. **Binary Search** — sorted arrays, first/last occurrence\r\n7. **HashMap** — frequency counting, two-sum, anagram detection\r\n8. **Trees** — BFS (level-order), DFS (max depth, path sum)\r\n9. **Graphs** — BFS shortest path, DFS cycle detection\r\n10. **DP** — state definition, transition, bottom-up vs top-down\r\n11. **Heap** — top-K problems\r\n12. **Backtracking, Prefix Sum, Intervals** — permutations, subarray sums, merging\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-12\"\u003e\u003c/a\u003e\r\n# MODULE 12: AI, LLMs \u0026 Spring AI\r\n\r\n\u003e **What this module is about:** AI is transforming backend development. Companies want developers who can build AI features — not just use ChatGPT. This module covers LLM fundamentals, Spring AI integration, RAG (Retrieval-Augmented Generation), embeddings, function calling, and production-ready AI patterns.\r\n\r\n---\r\n\r\n## 12.0 Internal Revision — AI/ML Basics\r\n\r\n### What is Artificial Intelligence?\r\n\r\n**Definition:** A broad field of computer science focused on creating systems that can perform tasks that typically require human intelligence: understanding language, recognizing images, making decisions.\r\n\r\n### What is Machine Learning?\r\n\r\n**Definition:** A subset of AI where systems learn from data instead of being explicitly programmed. Feed data → algorithm finds patterns → model makes predictions.\r\n\r\n```\r\nTraditional: IF email contains \"lottery\" AND sender is unknown → mark as spam (human writes rules)\r\nML:          Give 1 million labeled emails (spam/not-spam) → algorithm learns patterns → classifies new emails\r\n```\r\n\r\n### What is a Large Language Model (LLM)?\r\n\r\n**Definition:** A neural network trained on massive amounts of text data that can understand and generate human-like text. Examples: GPT-4, Claude, Gemini, LLaMA.\r\n\r\n**In plain English:** An LLM has read the entire internet. It predicts \"the next most likely word\" given the context. Through this simple mechanism (at massive scale), it can write code, explain concepts, translate languages, and reason about problems.\r\n\r\n### What is a Token?\r\n\r\n**Definition:** The basic unit of text that an LLM processes. Roughly 1 token ≈ 0.75 words. \"Hello world\" ≈ 2 tokens. \"Microservices architecture\" ≈ 3 tokens.\r\n\r\n### What is a Prompt?\r\n\r\n**Definition:** The text input you give to an LLM. A well-structured prompt leads to better output.\r\n\r\n```\r\nSystem prompt:  \"You are a Java expert. Give concise answers with code examples.\"\r\nUser prompt:    \"Explain the Builder pattern\"\r\n```\r\n\r\n### What is Temperature?\r\n\r\n**Definition:** A parameter that controls randomness in LLM output.\r\n- Temperature 0 → deterministic, same output every time (good for code generation)\r\n- Temperature 0.7 → balanced creativity\r\n- Temperature 1.0+ → very creative/random (good for brainstorming)\r\n\r\n---\r\n\r\n## 12.1 Spring AI — Getting Started\r\n\r\n### What is Spring AI?\r\n\r\n**Definition:** A Spring project that provides a consistent, Spring-friendly API for integrating with AI models (OpenAI, Azure OpenAI, Ollama, etc.). Just like Spring Data abstracts databases, Spring AI abstracts AI providers.\r\n\r\n```xml\r\n\u003c!-- pom.xml --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eorg.springframework.ai\u003c/groupId\u003e\r\n    \u003cartifactId\u003espring-ai-openai-spring-boot-starter\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n```\r\n\r\n```yaml\r\n# application.yml\r\nspring:\r\n  ai:\r\n    openai:\r\n      api-key: ${OPENAI_API_KEY}\r\n      chat:\r\n        model: gpt-4o\r\n        temperature: 0.7\r\n```\r\n\r\n```java\r\n@Service\r\npublic class AiService {\r\n    private final ChatClient chatClient;\r\n\r\n    public AiService(ChatClient.Builder builder) {\r\n        this.chatClient = builder.build();\r\n    }\r\n\r\n    public String ask(String question) {\r\n        return chatClient.prompt()\r\n            .user(question)\r\n            .call()\r\n            .content();\r\n    }\r\n\r\n    // Structured output — get a Java object back\r\n    public BookRecommendation getRecommendation(String genre) {\r\n        return chatClient.prompt()\r\n            .user(\"Recommend a \" + genre + \" book\")\r\n            .call()\r\n            .entity(BookRecommendation.class);  // auto-parsed from JSON\r\n    }\r\n}\r\n\r\nrecord BookRecommendation(String title, String author, String summary) {}\r\n```\r\n\r\n---\r\n\r\n## 12.2 Function Calling (Tool Use)\r\n\r\n### What is Function Calling?\r\n\r\n**Definition:** The ability of an LLM to decide it needs external data, request a specific function call (with parameters), receive the result, and incorporate it into its response. The LLM doesn\u0027t execute the function — YOUR code does.\r\n\r\n**In plain English:** The LLM says \"I need to check the weather in Mumbai — please call `getWeather(city=\u0027Mumbai\u0027)` and give me the result.\" Your backend executes the function, passes the result back, and the LLM uses it in its answer.\r\n\r\n```java\r\n// Define a function the LLM can call\r\n@Bean\r\n@Description(\"Get current weather for a city\")\r\npublic Function\u003cWeatherRequest, WeatherResponse\u003e getWeather() {\r\n    return request -\u003e weatherService.getCurrentWeather(request.city());\r\n}\r\n\r\nrecord WeatherRequest(String city) {}\r\nrecord WeatherResponse(double temperature, String condition) {}\r\n\r\n// The LLM will automatically call this when a user asks about weather\r\n// User: \"What\u0027s the weather in Mumbai?\"\r\n// LLM → calls getWeather(\"Mumbai\") → gets {32.5, \"Sunny\"} → responds \"It\u0027s 32.5°C and sunny in Mumbai\"\r\n```\r\n\r\n---\r\n\r\n## 12.3 Embeddings\r\n\r\n### What is an Embedding?\r\n\r\n**Definition:** A numerical vector (array of floats) that represents a piece of text in a high-dimensional space. Texts with similar meaning have similar vectors (close in the vector space).\r\n\r\n**In plain English:** Convert \"What is Java?\" to [0.02, -0.15, 0.87, ...] (1536 numbers for OpenAI). Convert \"Tell me about Java programming\" to a similar vector. The vectors are close → the texts are semantically similar.\r\n\r\n```java\r\n@Service\r\npublic class EmbeddingService {\r\n    private final EmbeddingModel embeddingModel;\r\n\r\n    // Convert text to a vector\r\n    public float[] embed(String text) {\r\n        return embeddingModel.embed(text);\r\n    }\r\n\r\n    // Find similarity between two texts\r\n    public double similarity(String text1, String text2) {\r\n        float[] v1 = embed(text1);\r\n        float[] v2 = embed(text2);\r\n        return cosineSimilarity(v1, v2);   // 1.0 = identical, 0 = unrelated\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 12.4 RAG — Retrieval-Augmented Generation\r\n\r\n### What is RAG?\r\n\r\n**Definition:** A pattern where you RETRIEVE relevant documents from your own data, then pass them as context to the LLM, which GENERATES an answer based on YOUR data — not just its training data.\r\n\r\n**Why RAG?** LLMs have a knowledge cutoff date and don\u0027t know your company\u0027s internal data. RAG lets the LLM answer questions about YOUR documents, products, policies, etc.\r\n\r\n### RAG Pipeline\r\n\r\n```\r\nStep 1: INGESTION (one-time)\r\n  Your docs → split into chunks → embed each chunk → store in vector DB (pgvector)\r\n\r\nStep 2: QUERY (every user question)\r\n  User question → embed → search vector DB for similar chunks → retrieve top 5\r\n\r\nStep 3: GENERATION\r\n  Send to LLM: \"Answer this question using ONLY the following context: [top 5 chunks]\"\r\n  LLM → generates answer grounded in YOUR data\r\n```\r\n\r\n### Spring AI RAG Implementation\r\n\r\n```java\r\n@Service\r\npublic class RagService {\r\n    private final VectorStore vectorStore;    // backed by pgvector\r\n    private final ChatClient chatClient;\r\n\r\n    // Ingest documents (run once)\r\n    public void ingestDocuments(List\u003cDocument\u003e documents) {\r\n        // Split into chunks, embed, and store\r\n        vectorStore.add(documents);\r\n    }\r\n\r\n    // Answer questions using RAG\r\n    public String askWithContext(String question) {\r\n        // 1. Retrieve relevant chunks\r\n        List\u003cDocument\u003e relevantDocs = vectorStore.similaritySearch(\r\n            SearchRequest.query(question).withTopK(5));\r\n\r\n        // 2. Build context string\r\n        String context = relevantDocs.stream()\r\n            .map(Document::getContent)\r\n            .collect(Collectors.joining(\"\\n\\n\"));\r\n\r\n        // 3. Ask LLM with context\r\n        return chatClient.prompt()\r\n            .system(\"Answer based ONLY on the provided context. If the answer is not in the context, say \u0027I don\u0027t know\u0027.\")\r\n            .user(\"Context:\\n\" + context + \"\\n\\nQuestion: \" + question)\r\n            .call()\r\n            .content();\r\n    }\r\n}\r\n```\r\n\r\n### pgvector for RAG\r\n\r\n```sql\r\n-- Store embeddings in PostgreSQL (requires pgvector extension)\r\nCREATE TABLE document_chunks (\r\n    id SERIAL PRIMARY KEY,\r\n    content TEXT,\r\n    metadata JSONB,\r\n    embedding vector(1536)     -- OpenAI embeds to 1536 dimensions\r\n);\r\n\r\nCREATE INDEX ON document_chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);\r\n```\r\n\r\n---\r\n\r\n## 12.5 Production Patterns for AI\r\n\r\n### Guardrails\r\n\r\n**Definition:** Input/output validation for LLM calls to prevent misuse, prompt injection, and inappropriate responses.\r\n\r\n```java\r\npublic String safeAsk(String userInput) {\r\n    // Input guardrail: block prompt injection attempts\r\n    if (userInput.contains(\"ignore previous instructions\")) {\r\n        return \"Invalid input.\";\r\n    }\r\n\r\n    String response = chatClient.prompt().user(userInput).call().content();\r\n\r\n    // Output guardrail: check for sensitive data leaks\r\n    if (containsPII(response)) {\r\n        return \"Response filtered for privacy.\";\r\n    }\r\n    return response;\r\n}\r\n```\r\n\r\n### Caching LLM Responses\r\n\r\n```java\r\n@Cacheable(value = \"ai-responses\", key = \"#question\")\r\npublic String ask(String question) {\r\n    return chatClient.prompt().user(question).call().content();\r\n}\r\n// Same question → cached response. Saves money ($$ per API call) and latency.\r\n```\r\n\r\n### Retry \u0026 Fallback\r\n\r\n```java\r\n@Retry(name = \"ai-service\", fallbackMethod = \"fallbackAnswer\")\r\npublic String ask(String question) {\r\n    return chatClient.prompt().user(question).call().content();\r\n}\r\n\r\npublic String fallbackAnswer(String question, Exception e) {\r\n    return \"AI service is temporarily unavailable. Please try again later.\";\r\n}\r\n```\r\n\r\n---\r\n\r\n## 12.6 ✅ What You\u0027ve Learnt After Module 12\r\n\r\n1. **AI/ML basics** — AI vs ML vs LLM, tokens, prompts, temperature\r\n2. **Spring AI** — ChatClient, structured output, provider-agnostic API\r\n3. **Function calling** — LLM requests tool execution, your code runs it\r\n4. **Embeddings** — text → vector, similarity search\r\n5. **RAG** — retrieve YOUR data → feed to LLM → grounded answers\r\n6. **pgvector** — vector storage in PostgreSQL for similarity search\r\n7. **Production patterns** — guardrails, caching, retry/fallback\r\n\r\n---\r\n---\r\n\r\n\u003ca id=\"module-13\"\u003e\u003c/a\u003e\r\n# MODULE 13: Behavioral Interview \u0026 Career Strategy\r\n\r\n\u003e **What this module is about:** Technical skills get you to the final round. Behavioral skills get you the offer. This module covers STAR storytelling, common questions, salary negotiation, and your 90-second introduction. Skip this and you risk losing offers you\u0027re technically qualified for.\r\n\r\n---\r\n\r\n## 13.0 Internal Revision — What Companies Actually Evaluate\r\n\r\n### Behavioral Interview = Culture Fit + Leadership Signals\r\n\r\nCompanies assess:\r\n1. **Communication** — Can you explain technical ideas clearly?\r\n2. **Ownership** — Do you take responsibility or blame others?\r\n3. **Conflict Resolution** — How do you handle disagreements?\r\n4. **Impact** — Did your work make a measurable difference?\r\n5. **Growth Mindset** — Do you learn from failures?\r\n6. **Leadership** — Can you influence without authority?\r\n\r\n### What is the STAR Method?\r\n\r\n**Definition:** A structured framework for answering behavioral questions:\r\n\r\n```\r\nS — Situation:  Set the scene. Where? When? What was happening?\r\nT — Task:       What was YOUR specific responsibility?\r\nA — Action:     What did YOU do? (Use \"I\", not \"we\")\r\nR — Result:     What was the outcome? Use NUMBERS if possible.\r\n```\r\n\r\n**Example:**\r\n```\r\nQ: \"Tell me about a time you improved system performance.\"\r\n\r\nS: \"In my last project, our order processing API had a P99 latency of 3 seconds\r\n    during peak hours, causing customer complaints.\"\r\n\r\nT: \"I was tasked with investigating and reducing the latency to under 500ms.\"\r\n\r\nA: \"I profiled the API and found two issues:\r\n    1. N+1 query in the order retrieval — I replaced it with a batch fetch using @EntityGraph\r\n    2. No caching — I added Redis cache-aside for product catalog data.\r\n    I also added EXPLAIN ANALYZE to identify missing indexes and created a composite\r\n    index on (user_id, order_date).\"\r\n\r\nR: \"P99 latency dropped from 3 seconds to 180ms — a 94% improvement.\r\n    Customer complaints about slowness dropped to zero. The team adopted my\r\n    caching pattern as a standard for all read-heavy endpoints.\"\r\n```\r\n\r\n---\r\n\r\n## 13.1 Your 90-Second Introduction\r\n\r\n### Template\r\n\r\n```\r\n\"Hi, I\u0027m [Name]. I have [X] years of experience in backend development,\r\nprimarily working with [Java/Spring Boot/your stack].\r\n\r\nCurrently at [Company], I [one-sentence about your current role and impact].\r\nFor example, [one specific achievement with numbers].\r\n\r\nBefore that, at [Previous Company], I [one-sentence about key accomplishment].\r\n\r\nI\u0027m looking for a senior role where I can [what you want — architect systems,\r\nmentor juniors, work on distributed systems, etc.].\r\n\r\nI\u0027m excited about [this company] because [specific reason — their tech, scale, product].\"\r\n```\r\n\r\n### Example\r\n\r\n```\r\n\"Hi, I\u0027m Rahul. I have 7 years of experience in backend development,\r\nworking primarily with Java 8, Spring Boot, and Oracle SQL.\r\n\r\nCurrently at TCS, I lead the backend team for a financial services platform\r\nserving 50K daily users. I recently optimized our reporting module, reducing\r\nquery time from 12 seconds to 800ms by restructuring SQL queries and adding\r\nproper indexing.\r\n\r\nBefore that, at Infosys, I built a REST API layer from scratch that handles\r\n2 million API calls daily with 99.95% uptime.\r\n\r\nI\u0027m looking for a senior role where I can architect distributed systems and\r\nwork with modern technologies like Kafka and Kubernetes.\r\n\r\nI\u0027m excited about this opportunity because your team works at scale with\r\nevent-driven architecture, which aligns perfectly with my career goals.\"\r\n```\r\n\r\n---\r\n\r\n## 13.2 Top 10 Behavioral Questions + Story Frameworks\r\n\r\n### 1. Tell me about yourself\r\n→ Use your 90-second intro above.\r\n\r\n### 2. Tell me about a challenging technical problem you solved\r\n→ STAR: P99 latency, N+1 query, production outage debugging. Use NUMBERS.\r\n\r\n### 3. Tell me about a time you disagreed with your team/manager\r\n```\r\nS: \"We disagreed on using synchronous REST vs async Kafka for inter-service communication.\"\r\nT: \"I needed to present a data-driven argument.\"\r\nA: \"I created a comparison document: latency benchmarks, failure handling, and coupling analysis.\r\n    I set up a POC with both approaches and demonstrated that async reduced coupling and\r\n    improved resilience.\"\r\nR: \"The team adopted async messaging. Over 6 months, we had zero cascading failures —\r\n    previously we had 3 per quarter.\"\r\n```\r\n\r\n### 4. Tell me about a time you failed\r\n```\r\nS: \"I pushed a database migration to production without testing it thoroughly.\"\r\nT: \"The migration locked a critical table for 45 minutes during business hours.\"\r\nA: \"I immediately rolled back, communicated the issue to stakeholders, and wrote a\r\n    post-mortem. I then implemented a pre-migration checklist and made staging environment\r\n    testing mandatory for all DB changes.\"\r\nR: \"Zero database-related incidents in the following 12 months. The checklist became\r\n    team standard.\"\r\n```\r\n\r\n### 5. How do you handle tight deadlines?\r\n→ Prioritization, scope negotiation, communication to stakeholders.\r\n\r\n### 6. Tell me about a time you mentored someone\r\n→ Explain HOW you taught — code reviews, pairing, documentation.\r\n\r\n### 7. Tell me about a time you had to learn something new quickly\r\n→ Java 21 features, Kafka, Kubernetes — HOW you learned and applied it.\r\n\r\n### 8. How do you handle production incidents?\r\n→ Acknowledge, stabilize, root cause, fix, post-mortem, prevention.\r\n\r\n### 9. Tell me about a time you improved a process\r\n→ CI/CD pipeline setup, code review standards, automated testing introduction.\r\n\r\n### 10. Why are you leaving your current job?\r\n```\r\nDO say: \"I\u0027m looking for more technical challenges, modern tech stack, and a role where\r\n         I can architect systems at a larger scale.\"\r\nDON\u0027T say: \"My manager is bad\" / \"The salary is low\" / \"I\u0027m bored\"\r\n```\r\n\r\n---\r\n\r\n## 13.3 Salary Negotiation\r\n\r\n### Key Rules\r\n\r\n1. **Never share your current salary.** Say: \"I\u0027d prefer to discuss what this role is worth rather than anchor to my current compensation.\"\r\n2. **Know your market value.** Check: Glassdoor, levels.fyi, AmbitionBox, and talk to peers.\r\n3. **Give a range, not a number.** \"Based on my research for this role and my experience, I\u0027d expect something in the range of ₹X to ₹Y.\"\r\n4. **Negotiate AFTER the offer.** Never discuss salary in early rounds. Let them decide they want you first.\r\n5. **Negotiate total comp.** Salary + bonus + stock + joining bonus + benefits.\r\n6. **Take your time.** \"Thank you for the offer. Can I have 48 hours to review it?\"\r\n7. **Always be polite.** \"I\u0027m very excited about this opportunity. I was hoping we could discuss the compensation to make sure it aligns with my experience level.\"\r\n\r\n### If Asked \"What\u0027s Your Expected Salary?\"\r\n\r\n```\r\nEarly stages: \"I\u0027d like to learn more about the role and responsibilities before discussing\r\ncompensation. I\u0027m sure we can find a number that works for both sides.\"\r\n\r\nAfter offer: \"Based on my 7+ years of experience, the market rate for this role,\r\nand the scope of responsibilities discussed, I was looking at ₹X - ₹Y.\r\nIs that within the band for this position?\"\r\n```\r\n\r\n---\r\n\r\n## 13.4 Resume Tips for 7+ YoE\r\n\r\n```\r\nFORMAT:\r\n  - 2 pages maximum\r\n  - Reverse chronological (latest job first)\r\n  - PDF format (not Word)\r\n\r\nEACH ROLE should have:\r\n  - Title, Company, Duration\r\n  - 3-5 bullet points with IMPACT\r\n  - Use the XYZ formula: \"Accomplished X by doing Y, resulting in Z\"\r\n\r\nEXAMPLE BULLETS:\r\n  ✅ \"Reduced API response time by 85% (3s → 450ms) by implementing Redis caching\r\n      and optimizing N+1 SQL queries, improving customer satisfaction score by 12%.\"\r\n  ✅ \"Designed and implemented event-driven order processing using Kafka, handling\r\n      50K events/day with zero data loss and exactly-once delivery semantics.\"\r\n  ❌ \"Worked on backend development\" (too vague)\r\n  ❌ \"Did bug fixing and maintenance\" (shows no initiative)\r\n\r\nSKILLS SECTION:\r\n  - Put: Java 21, Spring Boot 3.x, PostgreSQL, Kafka, Redis, Docker, Kubernetes, AWS\r\n  - Don\u0027t put: HTML, CSS, Microsoft Word (irrelevant for backend senior)\r\n```\r\n\r\n---\r\n\r\n## 13.5 ✅ What You\u0027ve Learnt After Module 13\r\n\r\n1. **STAR method** — structured storytelling for behavioral questions\r\n2. **90-second intro** — hook the interviewer in the first minute\r\n3. **Top 10 questions** — prepared stories with measurable results\r\n4. **Salary negotiation** — never share current salary, negotiate after offer\r\n5. **Resume** — XYZ formula, impact-driven bullet points, 2 pages max\r\n\r\n---\r\n---\r\n\r\n# 🎓 FINAL SUMMARY — Your Complete Interview Toolkit\r\n\r\n| Module | Topic | Key Takeaway |\r\n|--------|-------|-------------|\r\n| 1 | Java 8 → 21 | Records, sealed classes, virtual threads, pattern matching |\r\n| 2 | Java Internals | JVM, GC, classloading, memory model, threads |\r\n| 3 | Spring Boot 2 → 3 | javax→jakarta, SecurityFilterChain, Spring AI, JPA tuning |\r\n| 4 | Microservices | Saga, circuit breaker, outbox, CQRS, event sourcing |\r\n| 5 | Databases | Window functions, PostgreSQL, indexing, transactions, Redis, pgvector |\r\n| 6 | Kafka | Architecture, Spring Kafka, delivery guarantees, DLT |\r\n| 7 | API Design | REST best practices, pagination, idempotency, gRPC, GraphQL |\r\n| 8 | Docker/K8s/AWS | Containers, orchestration, cloud services, CI/CD, observability |\r\n| 9 | System Design | 5-step framework, URL shortener, chat, payment system |\r\n| 10 | LLD | SOLID, Strategy, Builder, Observer, Factory, Singleton, Decorator |\r\n| 11 | DSA | 13 patterns: two pointers, sliding window, DP, trees, graphs, heap |\r\n| 12 | AI/LLM | Spring AI, function calling, embeddings, RAG, pgvector |\r\n| 13 | Behavioral | STAR method, 90-sec intro, salary negotiation, resume |\r\n\r\n\u003e **You now have a complete, print-ready reference covering every topic asked in senior Java backend interviews. No other resource needed. Go clear those interviews! 🚀**\r\n\r\n---\r\n*End of Syllabus*\r\n","PSPath":"C:\\Users\\Public\\Documents\\Senior_Java_Backend_Interview_Syllabus.md","PSParentPath":"C:\\Users\\Public\\Documents","PSChildName":"Senior_Java_Backend_Interview_Syllabus.md","PSDrive":{"CurrentLocation":"Users\\SU20344175","Name":"C","Provider":{"ImplementingType":"Microsoft.PowerShell.Commands.FileSystemProvider","HelpFile":"System.Management.Automation.dll-Help.xml","Name":"FileSystem","PSSnapIn":"Microsoft.PowerShell.Core","ModuleName":"Microsoft.PowerShell.Core","Module":null,"Description":"","Capabilities":52,"Home":"C:\\Users\\SU20344175","Drives":"C D"},"Root":"C:\\","Description":"","MaximumSize":null,"Credential":{"UserName":null,"Password":null},"DisplayRoot":null},"PSProvider":{"ImplementingType":{"Module":"System.Management.Automation.dll","Assembly":"System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","TypeHandle":"System.RuntimeTypeHandle","DeclaringMethod":null,"BaseType":"System.Management.Automation.Provider.NavigationCmdletProvider","UnderlyingSystemType":"Microsoft.PowerShell.Commands.FileSystemProvider","FullName":"Microsoft.PowerShell.Commands.FileSystemProvider","AssemblyQualifiedName":"Microsoft.PowerShell.Commands.FileSystemProvider, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","Namespace":"Microsoft.PowerShell.Commands","GUID":"b4755d19-b6a7-38dc-ae06-4167f801062f","IsEnum":false,"GenericParameterAttributes":null,"IsSecurityCritical":true,"IsSecuritySafeCritical":false,"IsSecurityTransparent":false,"IsGenericTypeDefinition":false,"IsGenericParameter":false,"GenericParameterPosition":null,"IsGenericType":false,"IsConstructedGenericType":false,"ContainsGenericParameters":false,"StructLayoutAttribute":"System.Runtime.InteropServices.StructLayoutAttribute","Name":"FileSystemProvider","MemberType":32,"DeclaringType":null,"ReflectedType":null,"MetadataToken":33556356,"GenericTypeParameters":"","DeclaredConstructors":"Void .ctor() Void .cctor()","DeclaredEvents":"","DeclaredFields":"System.Collections.ObjectModel.Collection`1[System.Management.Automation.WildcardPattern] excludeMatcher System.Management.Automation.PSTraceSource tracer Int32 FILETRANSFERSIZE System.String ProviderName","DeclaredMembers":"System.String Mode(System.Management.Automation.PSObject) System.String NormalizePath(System.String) System.IO.FileSystemInfo GetFileSystemInfo(System.String, Boolean ByRef) Boolean IsFilterSet() System.Object GetChildNamesDynamicParameters(System.String) System.Object GetChildItemsDynamicParameters(System.String, Boolean) System.Object CopyItemDynamicParameters(System.String, System.String, Boolean) Boolean IsNetworkMappedDrive(System.Management.Automation.PSDriveInfo) Boolean IsSupportedDriveForPersistence(System.Management.Automation.PSDriveInfo) System.String GetRootPathForNetworkDriveOrDosDevice(System.IO.DriveInfo) System.Collections.ObjectModel.Collection`1[System.Management.Automation.PSDriveInfo] InitializeDefaultDrives() System.Object GetItemDynamicParameters(System.String) Void InvokeDefaultAction(System.String) Void GetChildItems(System.String, Boolean, UInt32) Void GetChildNames(System.String, System.Management.Automation.ReturnContainers) Boolean CheckItemExists(System.String, Boolean ByRef) System.Object RemoveItemDynamicParameters(System.String, Boolean) Void RemoveFileInfoItem(System.IO.FileInfo, Boolean) Boolean ItemExists(System.String) System.Object ItemExistsDynamicParameters(System.String) Boolean HasChildItems(System.String) Void CopyItemLocalOrToSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void InitilizeFunctionPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) Boolean ValidRemoteSessionForScripting(System.Management.Automation.Runspaces.Runspace) Void InitilizeFunctionsPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean PathIsReservedDeviceName(System.String, System.String) Boolean IsAbsolutePath(System.String) System.String GetCommonBase(System.String, System.String) System.String CreateNormalizedRelativePathFromStack(System.Collections.Generic.Stack`1[System.String]) Boolean IsItemContainer(System.String) Void MoveDirectoryInfoUnchecked(System.IO.DirectoryInfo, System.String, Boolean) Boolean IsSameVolume(System.String, System.String) System.Object GetPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object SetPropertyDynamicParameters(System.String, System.Management.Automation.PSObject) System.Object ClearPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object GetContentWriterDynamicParameters(System.String) System.Object ClearContentDynamicParameters(System.String) Int32 SafeGetFileAttributes(System.String) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorFromPath(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorOfType(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptor(ItemType) System.Management.Automation.ErrorRecord CreateErrorRecord(System.String, System.String) System.String GetHelpMaml(System.String, System.String) System.Management.Automation.ProviderInfo Start(System.Management.Automation.ProviderInfo) System.Management.Automation.PSDriveInfo NewDrive(System.Management.Automation.PSDriveInfo) Void MapNetworkDrive(System.Management.Automation.PSDriveInfo) System.Management.Automation.PSDriveInfo RemoveDrive(System.Management.Automation.PSDriveInfo) System.String GetUNCForNetworkDrive(System.String) System.String GetSubstitutedPathForNetworkDosDevice(System.String) Boolean IsValidPath(System.String) Void GetItem(System.String) System.IO.FileSystemInfo GetFileSystemItem(System.String, Boolean ByRef, Boolean) Boolean ConvertPath(System.String, System.String, System.String ByRef, System.String ByRef) Void GetPathItems(System.String, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers) Void Dir(System.IO.DirectoryInfo, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers, InodeTracker) System.Management.Automation.FlagsExpression`1[System.IO.FileAttributes] FormatAttributeSwitchParamters() Void RenameItem(System.String, System.String) Void NewItem(System.String, System.String, System.Object) ItemType GetItemType(System.String) Void CreateDirectory(System.String, Boolean) Boolean CreateIntermediateDirectories(System.String) Void RemoveItem(System.String, Boolean) Void RemoveDirectoryInfoItem(System.IO.DirectoryInfo, Boolean, Boolean, Boolean) Void RemoveFileSystemItem(System.IO.FileSystemInfo, Boolean) Boolean ItemExists(System.String, System.Management.Automation.ErrorRecord ByRef) Boolean DirectoryInfoHasChildItems(System.IO.DirectoryInfo) Void CopyItem(System.String, System.String, Boolean) Void CopyItemFromRemoteSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.Runspaces.PSSession) Void CopyDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void CopyFileInfoItem(System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell) Void CopyDirectoryFromRemoteSession(System.String, System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) System.Collections.ArrayList GetRemoteSourceAlternateStreams(System.Management.Automation.PowerShell, System.String) Void RemoveFunctionsPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) System.Collections.Hashtable GetRemoteFileMetadata(System.String, System.Management.Automation.PowerShell) Void SetFileMetadata(System.String, System.IO.FileInfo, System.Management.Automation.PowerShell) Void CopyFileFromRemoteSession(System.String, System.String, System.String, Boolean, System.Management.Automation.PowerShell, Int64) Boolean PerformCopyFileFromRemoteSession(System.String, System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell, Int64, Boolean, System.String) Void RemoveFunctionPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean RemoteTargetSupportsAlternateStreams(System.Management.Automation.PowerShell, System.String) System.String MakeRemotePath(System.Management.Automation.PowerShell, System.String, System.String) Boolean RemoteDirectoryExist(System.Management.Automation.PowerShell, System.String) Boolean CopyFileStreamToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell, Boolean, System.String) System.Collections.Hashtable GetFileMetadata(System.IO.FileInfo) Void SetRemoteFileMetadata(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean PerformCopyFileToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean RemoteDestinationPathIsFile(System.String, System.Management.Automation.PowerShell) System.String CreateDirectoryOnRemoteSession(System.String, Boolean, System.Management.Automation.PowerShell) System.String GetParentPath(System.String, System.String) Boolean IsUNCPath(System.String) Boolean IsUNCRoot(System.String) Boolean IsPathRoot(System.String) System.String NormalizeRelativePath(System.String, System.String) System.String NormalizeRelativePathHelper(System.String, System.String) System.String RemoveRelativeTokens(System.String) System.Collections.Generic.Stack`1[System.String] TokenizePathToStack(System.String, System.String) System.Collections.Generic.Stack`1[System.String] NormalizeThePath(System.String, System.Collections.Generic.Stack`1[System.String]) System.String GetChildName(System.String) System.String EnsureDriveIsRooted(System.String) Void MoveItem(System.String, System.String) Void MoveFileInfoItem(System.IO.FileInfo, System.String, Boolean, Boolean) Void MoveDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean) Void CopyAndDelete(System.IO.DirectoryInfo, System.String, Boolean) Void GetProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) Void SetProperty(System.String, System.Management.Automation.PSObject) Void ClearProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Management.Automation.Provider.IContentReader GetContentReader(System.String) System.Object GetContentReaderDynamicParameters(System.String) System.Management.Automation.Provider.IContentWriter GetContentWriter(System.String) Void ClearContent(System.String) Void ValidateParameters(Boolean) Void GetSecurityDescriptor(System.String, System.Security.AccessControl.AccessControlSections) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity, System.Security.AccessControl.AccessControlSections) Void \u003cRemoveDirectoryInfoItem\u003eg__WriteErrorHelper|43_0(System.Exception, \u003c\u003ec__DisplayClass43_0 ByRef) Void .ctor() Void .cctor() System.Collections.ObjectModel.Collection`1[System.Management.Automation.WildcardPattern] excludeMatcher System.Management.Automation.PSTraceSource tracer Int32 FILETRANSFERSIZE System.String ProviderName Microsoft.PowerShell.Commands.FileSystemProvider+ItemType Microsoft.PowerShell.Commands.FileSystemProvider+NativeMethods Microsoft.PowerShell.Commands.FileSystemProvider+NetResource Microsoft.PowerShell.Commands.FileSystemProvider+InodeTracker Microsoft.PowerShell.Commands.FileSystemProvider+\u003c\u003ec__DisplayClass43_0","DeclaredMethods":"System.String Mode(System.Management.Automation.PSObject) System.String NormalizePath(System.String) System.IO.FileSystemInfo GetFileSystemInfo(System.String, Boolean ByRef) Boolean IsFilterSet() System.Object GetChildNamesDynamicParameters(System.String) System.Object GetChildItemsDynamicParameters(System.String, Boolean) System.Object CopyItemDynamicParameters(System.String, System.String, Boolean) Boolean IsNetworkMappedDrive(System.Management.Automation.PSDriveInfo) Boolean IsSupportedDriveForPersistence(System.Management.Automation.PSDriveInfo) System.String GetRootPathForNetworkDriveOrDosDevice(System.IO.DriveInfo) System.Collections.ObjectModel.Collection`1[System.Management.Automation.PSDriveInfo] InitializeDefaultDrives() System.Object GetItemDynamicParameters(System.String) Void InvokeDefaultAction(System.String) Void GetChildItems(System.String, Boolean, UInt32) Void GetChildNames(System.String, System.Management.Automation.ReturnContainers) Boolean CheckItemExists(System.String, Boolean ByRef) System.Object RemoveItemDynamicParameters(System.String, Boolean) Void RemoveFileInfoItem(System.IO.FileInfo, Boolean) Boolean ItemExists(System.String) System.Object ItemExistsDynamicParameters(System.String) Boolean HasChildItems(System.String) Void CopyItemLocalOrToSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void InitilizeFunctionPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) Boolean ValidRemoteSessionForScripting(System.Management.Automation.Runspaces.Runspace) Void InitilizeFunctionsPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean PathIsReservedDeviceName(System.String, System.String) Boolean IsAbsolutePath(System.String) System.String GetCommonBase(System.String, System.String) System.String CreateNormalizedRelativePathFromStack(System.Collections.Generic.Stack`1[System.String]) Boolean IsItemContainer(System.String) Void MoveDirectoryInfoUnchecked(System.IO.DirectoryInfo, System.String, Boolean) Boolean IsSameVolume(System.String, System.String) System.Object GetPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object SetPropertyDynamicParameters(System.String, System.Management.Automation.PSObject) System.Object ClearPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object GetContentWriterDynamicParameters(System.String) System.Object ClearContentDynamicParameters(System.String) Int32 SafeGetFileAttributes(System.String) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorFromPath(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorOfType(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptor(ItemType) System.Management.Automation.ErrorRecord CreateErrorRecord(System.String, System.String) System.String GetHelpMaml(System.String, System.String) System.Management.Automation.ProviderInfo Start(System.Management.Automation.ProviderInfo) System.Management.Automation.PSDriveInfo NewDrive(System.Management.Automation.PSDriveInfo) Void MapNetworkDrive(System.Management.Automation.PSDriveInfo) System.Management.Automation.PSDriveInfo RemoveDrive(System.Management.Automation.PSDriveInfo) System.String GetUNCForNetworkDrive(System.String) System.String GetSubstitutedPathForNetworkDosDevice(System.String) Boolean IsValidPath(System.String) Void GetItem(System.String) System.IO.FileSystemInfo GetFileSystemItem(System.String, Boolean ByRef, Boolean) Boolean ConvertPath(System.String, System.String, System.String ByRef, System.String ByRef) Void GetPathItems(System.String, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers) Void Dir(System.IO.DirectoryInfo, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers, InodeTracker) System.Management.Automation.FlagsExpression`1[System.IO.FileAttributes] FormatAttributeSwitchParamters() Void RenameItem(System.String, System.String) Void NewItem(System.String, System.String, System.Object) ItemType GetItemType(System.String) Void CreateDirectory(System.String, Boolean) Boolean CreateIntermediateDirectories(System.String) Void RemoveItem(System.String, Boolean) Void RemoveDirectoryInfoItem(System.IO.DirectoryInfo, Boolean, Boolean, Boolean) Void RemoveFileSystemItem(System.IO.FileSystemInfo, Boolean) Boolean ItemExists(System.String, System.Management.Automation.ErrorRecord ByRef) Boolean DirectoryInfoHasChildItems(System.IO.DirectoryInfo) Void CopyItem(System.String, System.String, Boolean) Void CopyItemFromRemoteSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.Runspaces.PSSession) Void CopyDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void CopyFileInfoItem(System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell) Void CopyDirectoryFromRemoteSession(System.String, System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) System.Collections.ArrayList GetRemoteSourceAlternateStreams(System.Management.Automation.PowerShell, System.String) Void RemoveFunctionsPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) System.Collections.Hashtable GetRemoteFileMetadata(System.String, System.Management.Automation.PowerShell) Void SetFileMetadata(System.String, System.IO.FileInfo, System.Management.Automation.PowerShell) Void CopyFileFromRemoteSession(System.String, System.String, System.String, Boolean, System.Management.Automation.PowerShell, Int64) Boolean PerformCopyFileFromRemoteSession(System.String, System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell, Int64, Boolean, System.String) Void RemoveFunctionPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean RemoteTargetSupportsAlternateStreams(System.Management.Automation.PowerShell, System.String) System.String MakeRemotePath(System.Management.Automation.PowerShell, System.String, System.String) Boolean RemoteDirectoryExist(System.Management.Automation.PowerShell, System.String) Boolean CopyFileStreamToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell, Boolean, System.String) System.Collections.Hashtable GetFileMetadata(System.IO.FileInfo) Void SetRemoteFileMetadata(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean PerformCopyFileToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean RemoteDestinationPathIsFile(System.String, System.Management.Automation.PowerShell) System.String CreateDirectoryOnRemoteSession(System.String, Boolean, System.Management.Automation.PowerShell) System.String GetParentPath(System.String, System.String) Boolean IsUNCPath(System.String) Boolean IsUNCRoot(System.String) Boolean IsPathRoot(System.String) System.String NormalizeRelativePath(System.String, System.String) System.String NormalizeRelativePathHelper(System.String, System.String) System.String RemoveRelativeTokens(System.String) System.Collections.Generic.Stack`1[System.String] TokenizePathToStack(System.String, System.String) System.Collections.Generic.Stack`1[System.String] NormalizeThePath(System.String, System.Collections.Generic.Stack`1[System.String]) System.String GetChildName(System.String) System.String EnsureDriveIsRooted(System.String) Void MoveItem(System.String, System.String) Void MoveFileInfoItem(System.IO.FileInfo, System.String, Boolean, Boolean) Void MoveDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean) Void CopyAndDelete(System.IO.DirectoryInfo, System.String, Boolean) Void GetProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) Void SetProperty(System.String, System.Management.Automation.PSObject) Void ClearProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Management.Automation.Provider.IContentReader GetContentReader(System.String) System.Object GetContentReaderDynamicParameters(System.String) System.Management.Automation.Provider.IContentWriter GetContentWriter(System.String) Void ClearContent(System.String) Void ValidateParameters(Boolean) Void GetSecurityDescriptor(System.String, System.Security.AccessControl.AccessControlSections) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity, System.Security.AccessControl.AccessControlSections) Void \u003cRemoveDirectoryInfoItem\u003eg__WriteErrorHelper|43_0(System.Exception, \u003c\u003ec__DisplayClass43_0 ByRef)","DeclaredNestedTypes":"Microsoft.PowerShell.Commands.FileSystemProvider+ItemType Microsoft.PowerShell.Commands.FileSystemProvider+NativeMethods Microsoft.PowerShell.Commands.FileSystemProvider+NetResource Microsoft.PowerShell.Commands.FileSystemProvider+InodeTracker Microsoft.PowerShell.Commands.FileSystemProvider+\u003c\u003ec__DisplayClass43_0","DeclaredProperties":"","ImplementedInterfaces":"System.Management.Automation.IResourceSupplier System.Management.Automation.Provider.IContentCmdletProvider System.Management.Automation.Provider.IPropertyCmdletProvider System.Management.Automation.Provider.ISecurityDescriptorCmdletProvider System.Management.Automation.Provider.ICmdletProviderSupportsHelp","TypeInitializer":"Void .cctor()","IsNested":false,"Attributes":1048833,"IsVisible":true,"IsNotPublic":false,"IsPublic":true,"IsNestedPublic":false,"IsNestedPrivate":false,"IsNestedFamily":false,"IsNestedAssembly":false,"IsNestedFamANDAssem":false,"IsNestedFamORAssem":false,"IsAutoLayout":true,"IsLayoutSequential":false,"IsExplicitLayout":false,"IsClass":true,"IsInterface":false,"IsValueType":false,"IsAbstract":false,"IsSealed":true,"IsSpecialName":false,"IsImport":false,"IsSerializable":false,"IsAnsiClass":true,"IsUnicodeClass":false,"IsAutoClass":false,"IsArray":false,"IsByRef":false,"IsPointer":false,"IsPrimitive":false,"IsCOMObject":false,"HasElementType":false,"IsContextful":false,"IsMarshalByRef":false,"GenericTypeArguments":"","CustomAttributes":"[System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.String), typeof(System.IO.FileInfo) }, ProviderCmdlet = \"New-Item\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.Security.AccessControl.FileSecurity), ProviderCmdlet = \"Set-Acl\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.String), typeof(System.Management.Automation.PathInfo) }, ProviderCmdlet = \"Resolve-Path\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.Management.Automation.PathInfo), ProviderCmdlet = \"Push-Location\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.Byte), typeof(System.String) }, ProviderCmdlet = \"Get-Content\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.IO.FileInfo), ProviderCmdlet = \"Get-Item\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-ChildItem\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.Security.AccessControl.FileSecurity), typeof(System.Security.AccessControl.DirectorySecurity) }, ProviderCmdlet = \"Get-Acl\")] [System.Management.Automation.OutputTypeAttribute(new Type[4] { typeof(System.Boolean), typeof(System.String), typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-Item\")] [System.Management.Automation.OutputTypeAttribute(new Type[5] { typeof(System.Boolean), typeof(System.String), typeof(System.DateTime), typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-ItemProperty\")] [System.Management.Automation.Provider.CmdletProviderAttribute(\"FileSystem\", (System.Management.Automation.Provider.ProviderCapabilities)52)]"},"HelpFile":"System.Management.Automation.dll-Help.xml","Name":"FileSystem","PSSnapIn":{"Name":"Microsoft.PowerShell.Core","IsDefault":true,"ApplicationBase":"C:\\Windows\\System32\\WindowsPowerShell\\v1.0","AssemblyName":"System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, ProcessorArchitecture=MSIL","ModuleName":"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\System.Management.Automation.dll","PSVersion":"5.1.26100.7462","Version":"3.0.0.0","Types":"types.ps1xml typesv3.ps1xml","Formats":"Certificate.format.ps1xml DotNetTypes.format.ps1xml FileSystem.format.ps1xml Help.format.ps1xml HelpV3.format.ps1xml PowerShellCore.format.ps1xml PowerShellTrace.format.ps1xml Registry.format.ps1xml","Description":"This Windows PowerShell snap-in contains cmdlets used to manage components of Windows PowerShell.","Vendor":"Microsoft Corporation","LogPipelineExecutionDetails":false},"ModuleName":"Microsoft.PowerShell.Core","Module":null,"Description":"","Capabilities":52,"Home":"C:\\Users\\SU20344175","Drives":["C","D"]},"ReadCount":1};
